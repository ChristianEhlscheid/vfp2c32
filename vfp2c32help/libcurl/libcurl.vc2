*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="libcurl.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS libcurl AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblname" UniqueID="" Timestamp="" />

	#INCLUDE "libcurl.h"
	*<DefinedPropArrayMethod>
		*m: canceltransfer		&& This methd cancels the current transfer.
		*m: curleasyescape
		*m: curleasyperform		&& Perform a file transfer.
		*m: curleasyreset		&& Reset all options of a libcurl session handle.
		*m: curleasystrerror		&& Return string describing error code.
		*m: curleasyunescape
		*m: curlinfoeffectiveurl
		*m: curlinfoperformcode
		*m: curlinforesponsecode
		*m: curloptappend_assign
		*m: curloptautoreferer_assign
		*m: curloptcookie_assign
		*m: curloptcopypostfields_assign
		*m: curloptcrlf_assign
		*m: curloptcustomrequest_assign
		*m: curloptdirlistonly_assign
		*m: curloptfiletime_assign
		*m: curloptfollowlocation_assign
		*m: curloptftpaccount_assign
		*m: curloptftpcreatemissingdirs_assign
		*m: curloptftpfilemethod_assign
		*m: curloptftpport_assign
		*m: curloptftpresponsetimeout_assign
		*m: curloptftpsslauth_assign
		*m: curloptftpsslccc_assign
		*m: curloptheader_assign
		*m: curlopthttpauth_assign
		*m: curlopthttpget_assign
		*m: curlopthttpheader_assign
		*m: curlopthttpproxytunnel_assign
		*m: curloptinterface_assign
		*m: curloptlocalportrange_assign
		*m: curloptlocalport_assign
		*m: curloptmaxrecvspeed_assign
		*m: curloptmaxredirs_assign
		*m: curloptmaxsendspeed_assign
		*m: curloptnobody_assign
		*m: curloptport_assign
		*m: curloptpost301_assign
		*m: curloptpostfieldsize_assign
		*m: curloptpostquote_assign
		*m: curloptpost_assign
		*m: curloptprequote_assign
		*m: curloptprogress_assign
		*m: curloptproxyauth_assign
		*m: curloptproxyport_assign
		*m: curloptproxytype_assign
		*m: curloptproxyuserpwd_assign
		*m: curloptproxy_assign
		*m: curloptquote_assign
		*m: curloptrange_assign
		*m: curloptreferer_assign
		*m: curloptresumefrom_assign
		*m: curloptsslverifyhost_assign
		*m: curloptsslverifypeer_assign
		*m: curloptsslversion_assign
		*m: curlopttimeout_assign
		*m: curlopttransfertext_assign
		*m: curloptunrestrictedauth_assign
		*m: curloptupload_assign
		*m: curlopturl_assign
		*m: curloptuseragent_assign
		*m: curloptuserpwd_assign
		*m: curloptusessl_assign		&& Sets the level of SSL for ftp.
		*m: curloptverbose_assign
		*m: curlversion		&& Returns a human readable string with the version number of libcurl and some of its important components.
		*m: downloadfile		&& Downloads a remote file to a local file.
		*m: downloadstring		&& Downloads a remote file to a string.
		*m: filedownloadfile		&& Downloads a remote file to a local file usinf the FILE protocol.
		*m: filedownloadstring		&& Downloads a remote file to a string using the FILE protocol.
		*m: fileuploadfile		&& Uploads a file using the FTP protocol.
		*m: fileuploadstring		&& Uploads a string using the ftp protocol.
		*m: formatbytesize
		*m: formattimeseconds
		*m: ftpappendfile		&& Represents the FTP protocol APPE method that is used to append a file to an existing file on an FTP server.
		*m: ftpappendstring		&& Represents the FTP protocol APPE method that is used to append a string to an existing file on an FTP server.
		*m: ftpdeletefile		&& Represents the FTP protocol DELE method that is used to delete a file on an FTP server.
		*m: ftpdownloadfile		&& Downloads a remote file to a local file using the FTP protocol.
		*m: ftpdownloadstring		&& Downloads a remote file to a string using the FTP protocol.
		*m: ftpgetdatetimestamp		&& Retrieves the date-time stamp of a remote file using the FTP protocol.
		*m: ftpgetfeatures		&& Represents the FTP protocol FEAT method that is used to retrieve the features of an FTP server.
		*m: ftpgetfilesize		&& Retrieves the size of a remote file using the FTP protocol.
		*m: ftplist		&& Fills the Ftpfiles array with information about an FTP directory.
		*m: ftplistdirectory		&& Represents the FTP protocol NLIST method that gets a short listing of the files on an FTP server.
		*m: ftplistdirectorydetails		&& Represents the FTP protocol LIST method that gets a detailed listing of the files on an FTP server.
		*m: ftpmakedirectory		&& Represents the FTP protocol MKD method that creates a directory on an FTP server.
		*m: ftpnoop		&& Represents the FTP protocol  NOOP command.
		*m: ftpremovedirectory		&& Represents the FTP protocol RMD method that removes a directory.
		*m: ftprename		&& Represents the FTP protocol RNFR and RNTO methods that renames a file.
		*m: ftpuploadfile		&& Uploads a file using the FTP protocol.
		*m: ftpuploadstring		&& Uploads a string using the ftp protocol.
		*m: getdatetimestamp		&& Retrieves the date-time stamp of a remote file.
		*m: getfilesize		&& Retrieves the size of a remote file.
		*m: httpdownloadfile		&& Downloads a remote file to a local file using the HTTP protocol.
		*m: httpdownloadstring		&& Downloads a remote file to a string using the HTPP protocol.
		*m: httpgetdatetimestamp		&& Retrieves the date-time stamp of a remote file using the HTPP protocol.
		*m: httpgetfilesize		&& Retrieves the size of a remote file using the HTPP protocol.
		*m: httppostfile		&& Performs an HTTP POST of the specified file.
		*m: httppoststring		&& Performs an HTTP POST of the specified string.
		*m: httpuploadfile		&& Uploads a file using the HTPP protocol.
		*m: httpuploadstring		&& Uploads a string using the HTPP protocol.
		*m: logfilereset		&& Resets the log file
		*m: transferprogress		&& Event. Fires about every second. when a transfer is in progress.
		*m: uploadfile		&& Uploads a file.
		*m: uploadstring		&& Uploads a string.
		*m: _clearslists
		*m: _createcallbacks
		*m: _debugcallback		&& Replaces the standard debug function used when CurlOptVerbose is in effect. This method receives debug information.
		*m: _destroycallbacks
		*m: _fileclose		&& Flushes and closes a file or communication port opened with a low-level file function.
		*m: _filecreate		&& Creates and opens a low-level file.
		*m: _fileopen		&& Opens a file for use with low-level file functions.
		*m: _fileread
		*m: _fileseek		&& Moves the file pointer in a file opened with a low-level file Moves the file pointer in a file opened with a low-level file Moves the file pointer in a file opened with a low-level file function.
		*m: _filesize
		*m: _filewrite
		*m: _ftplistmlsd
		*m: _ftplistplain
		*m: _gettickcount
		*m: _headercallback
		*m: _progresscallback		&& This function gets called by libcurl with a frequent interval during operation.
		*m: _readcallback		&& This function gets called by libcurl as soon as it needs to read data in order to send it to the peer.
		*m: _restoresettings
		*m: _savesettings
		*m: _seekcallback		&& This function gets called by libcurl to seek to a certain position in the input stream and can be used to fast forward a file in a resumed upload.
		*m: _setdefaultproperties
		*m: _setuplogfile
		*m: _writecallback		&& This function gets called by libcurl as soon as there is data received that needs to be saved.
		*p: curleasyhandle		&& Returns the easyhandle in use.
		*p: curloptappend		&& A parameter set to 1 tells the library to append to the remote file instead of overwrite it. This is only useful when uploading to an ftp site.
		*p: curloptautoreferer		&& If TRUE, libcurl will automatically set the Referer: field in requests where it follows a Location: redirect.
		*p: curloptcookie		&& Sets a cookie in the http request.
		*p: curloptcopypostfields		&& Specifies the data to post in an HTTP POST operation.
		*p: curloptcrlf		&& Convert Unix newlines to CRLF newlines on transfers.
		*p: curloptcustomrequest		&& This will be used instead of  LIST or NLST when doing an ftp directory listing.
		*p: curloptdirlistonly		&& A parameter set to 1 tells the library to just list the names of files in a directory, instead of doing a full directory listing that would include file sizes, dates etc. This works for FTP and SFTP URLs.
		*p: curloptfiletime		&& Attempt to get the modification date of the remote document in this operation.
		*p: curloptfollowlocation		&& A parameter set to 1 tells the library to follow any Location: header that the server sends as part of an HTTP header.
		*p: curloptftpaccount		&& Account data to use for FTP servers.
		*p: curloptftpcreatemissingdirs		&& Pass a long. If the value is 1, curl will attempt to create any remote directory that it fails to CWD into. CWD is the command that changes working directory.
		*p: curloptftpfilemethod		&& Controls what method libcurl should use to reach a file on a FTP server.
		*p: curloptftpport		&& Specifies the IP address to use for the ftp PORT instruction. If set, FTP passive mode is disabled.
		*p: curloptftpresponsetimeout		&& Pass a long. Causes curl to set a timeout period (in seconds) on the amount of time that the server is allowed to take in order to generate a response message for a command before the session is considered hung.
		*p: curloptftpsslauth		&& Pass a long to alter how libcurl issues "AUTH TLS" or "AUTH SSL" when FTP over SSL is activated.
		*p: curloptftpsslccc		&& If enabled, this option makes libcurl use CCC (Clear Command Channel).
		*p: curloptheader		&& If TRUE, tells the library to include the header in the body output.
		*p: curlopthttpauth		&& Authentication method(s) to use.
		*p: curlopthttpget		&& Forces the HTTP request to get back to GET.
		*p: curlopthttpheader		&& List of HTTP headers to pass to the server in your HTTP request.
		*p: curlopthttpproxytunnel		&& Set the parameter to 1 to make the library tunnel all operations through a given HTTP proxy.
		*p: curloptinterface		&& Specifies the interface name to use as outgoing network interface. The name can be an interface name, an IP address or a host name.
		*p: curloptlocalport		&& Specifies the local port number of the socket used for connection. Valid range is 1-65535. See CurlOptLocalPortRange.
		*p: curloptlocalportrange		&& Range of local ports to use starting with CurlOptLocalPort.
		*p: curloptmaxrecvspeed		&& Specifies the masimum download speed.
		*p: curloptmaxredirs		&& Specifies the redirection limit.
		*p: curloptmaxsendspeed		&& Specifies the maximum upload speed.
		*p: curloptnobody		&& A parameter set to 1 tells the library to not include the body-part in the output.
		*p: curloptport		&& Pass a long specifying what remote port number to connect to, instead of the one specified in the URL or the default port for the used protocol.
		*p: curloptpost		&& If TRUE, tells the library to do a regular HTTP post.
		*p: curloptpost301		&& If TRUE, tells the library to respect RFC 2616/10.3.2 and not convert POST requests into GET requests when following a 301 redirection.
		*p: curloptpostfieldsize		&& Size of the POST data.
		*p: curloptpostquote		&& List of FTP or SFTP commands to pass to the server after your ftp transfer request.
		*p: curloptprequote		&& List of FTP commands to pass to the server after the transfer type is set.
		*p: curloptprogress		&& If TRUE, enables the CurlProgressCallBack function.
		*p: curloptproxy		&& Set HTTP proxy to use.
		*p: curloptproxyauth		&& Bitmask,to tell libcurl what authentication method(s) you want it to use for your proxy authentication.
		*p: curloptproxyport		&& Sets the proxy port to connect to unless it is specified in CurlOptProxy
		*p: curloptproxytype		&& Sets the type of proxy.
		*p: curloptproxyuserpwd		&& Set user name:password to use for the connection to the HTTP proxy.
		*p: curloptquote		&& List of FTP or SFTP commands to pass to the server prior to your ftp request. This will be done before any other commands are issued.
		*p: curloptrange		&& String which should contain the specified range you want. It should be in the format "X-Y", where X or Y may be left out.
		*p: curloptreferer		&& Used to set the Referer: header in the http request sent to the remote server.
		*p: curloptresumefrom		&& Offset in number of bytes that you want the transfer to start from.
		*p: curloptsslverifyhost		&& Determines whether libcurl verifies that the server cert is for the server it is known as.
		*p: curloptsslverifypeer		&& This option determines whether curl verifies the authenticity of the peer's certificate.
		*p: curloptsslversion		&& Version of SSL/TLS to attempt to use.
		*p: curlopttimeout		&& Specifies the maximum time in seconds that you allow the libcurl transfer operation to take.
		*p: curlopttransfertext		&& Use ASCII mode for ftp transfers.
		*p: curloptunrestrictedauth		&& If TRUE, tells the library it can continue to send authentication (user+password) when following locations, even when hostname changed.
		*p: curloptupload		&& Set to 1 to tell the library to prepare for an upload.
		*p: curlopturl		&& The actual URL to deal with.
		*p: curloptuseragent		&& Sets the User-Agent: header in http requests.
		*p: curloptuserpwd		&& Set user name:password]to use for the connection.
		*p: curloptusessl
		*p: curloptverbose		&& Set the parameter to 1 to get the library to display a lot of verbose information.
		*p: ftpfilecount
		*p: logfilename		&& Name of the log file.
		*a: ftpfiles[1,4]
		*a: _settings[1,0]
		*p: _canceltransfer		&& This is set to TRUE by the CancelTTransfer Method.
		*p: _databuffer		&& Buffer used to store received data
		*p: _debugcallbackptr
		*p: _debugfilehandle
		*p: _ftpgetfeaturesdata
		*p: _ftpgetfeaturesstatus
		*p: _headercallbackptr
		*p: _headerslist
		*p: _performlastcode
		*p: _performretcode		&& Overrides the CurlEasyPerform return code with this value.
		*p: _performstarttime
		*p: _postquoteslist
		*p: _prequoteslist
		*p: _progresscallbackptr
		*p: _progresscallbacktickcount
		*p: _quoteslist
		*p: _readcallbackptr
		*p: _seekcallbackptr
		*p: _writecallbackptr
	*</DefinedPropArrayMethod>

	BackColor = 140,200,200
	curleasyhandle = 0		&& Returns the easyhandle in use.
	curloptappend = .F.		&& A parameter set to 1 tells the library to append to the remote file instead of overwrite it. This is only useful when uploading to an ftp site.
	curloptautoreferer = .F.		&& If TRUE, libcurl will automatically set the Referer: field in requests where it follows a Location: redirect.
	curloptcookie = 		&& Sets a cookie in the http request.
	curloptcopypostfields = 		&& Specifies the data to post in an HTTP POST operation.
	curloptcrlf = .F.		&& Convert Unix newlines to CRLF newlines on transfers.
	curloptcustomrequest = 		&& This will be used instead of  LIST or NLST when doing an ftp directory listing.
	curloptdirlistonly = .F.		&& A parameter set to 1 tells the library to just list the names of files in a directory, instead of doing a full directory listing that would include file sizes, dates etc. This works for FTP and SFTP URLs.
	curloptfiletime = .F.		&& Attempt to get the modification date of the remote document in this operation.
	curloptfollowlocation = .F.		&& A parameter set to 1 tells the library to follow any Location: header that the server sends as part of an HTTP header.
	curloptftpaccount = 		&& Account data to use for FTP servers.
	curloptftpcreatemissingdirs = .F.		&& Pass a long. If the value is 1, curl will attempt to create any remote directory that it fails to CWD into. CWD is the command that changes working directory.
	curloptftpfilemethod = 0		&& Controls what method libcurl should use to reach a file on a FTP server.
	curloptftpport = 		&& Specifies the IP address to use for the ftp PORT instruction. If set, FTP passive mode is disabled.
	curloptftpresponsetimeout = 0		&& Pass a long. Causes curl to set a timeout period (in seconds) on the amount of time that the server is allowed to take in order to generate a response message for a command before the session is considered hung.
	curloptftpsslauth = 0		&& Pass a long to alter how libcurl issues "AUTH TLS" or "AUTH SSL" when FTP over SSL is activated.
	curloptftpsslccc = 0		&& If enabled, this option makes libcurl use CCC (Clear Command Channel).
	curloptheader = .F.		&& If TRUE, tells the library to include the header in the body output.
	curlopthttpauth = 1		&& Authentication method(s) to use.
	curlopthttpget = .F.		&& Forces the HTTP request to get back to GET.
	curlopthttpheader = 		&& List of HTTP headers to pass to the server in your HTTP request.
	curlopthttpproxytunnel = .F.		&& Set the parameter to 1 to make the library tunnel all operations through a given HTTP proxy.
	curloptinterface = 		&& Specifies the interface name to use as outgoing network interface. The name can be an interface name, an IP address or a host name.
	curloptlocalport = 0		&& Specifies the local port number of the socket used for connection. Valid range is 1-65535. See CurlOptLocalPortRange.
	curloptlocalportrange = 0		&& Range of local ports to use starting with CurlOptLocalPort.
	curloptmaxrecvspeed = 0		&& Specifies the masimum download speed.
	curloptmaxredirs = -1		&& Specifies the redirection limit.
	curloptmaxsendspeed = 0		&& Specifies the maximum upload speed.
	curloptnobody = .F.		&& A parameter set to 1 tells the library to not include the body-part in the output.
	curloptport = 0		&& Pass a long specifying what remote port number to connect to, instead of the one specified in the URL or the default port for the used protocol.
	curloptpost = .F.		&& If TRUE, tells the library to do a regular HTTP post.
	curloptpost301 = .T.		&& If TRUE, tells the library to respect RFC 2616/10.3.2 and not convert POST requests into GET requests when following a 301 redirection.
	curloptpostfieldsize = -1		&& Size of the POST data.
	curloptpostquote = 		&& List of FTP or SFTP commands to pass to the server after your ftp transfer request.
	curloptprequote = 		&& List of FTP commands to pass to the server after the transfer type is set.
	curloptprogress = .T.		&& If TRUE, enables the CurlProgressCallBack function.
	curloptproxy = 		&& Set HTTP proxy to use.
	curloptproxyauth = 0		&& Bitmask,to tell libcurl what authentication method(s) you want it to use for your proxy authentication.
	curloptproxyport = 0		&& Sets the proxy port to connect to unless it is specified in CurlOptProxy
	curloptproxytype = 0		&& Sets the type of proxy.
	curloptproxyuserpwd = 		&& Set user name:password to use for the connection to the HTTP proxy.
	curloptquote = 		&& List of FTP or SFTP commands to pass to the server prior to your ftp request. This will be done before any other commands are issued.
	curloptrange = 		&& String which should contain the specified range you want. It should be in the format "X-Y", where X or Y may be left out.
	curloptreferer = 		&& Used to set the Referer: header in the http request sent to the remote server.
	curloptresumefrom = 0		&& Offset in number of bytes that you want the transfer to start from.
	curloptsslverifyhost = 2		&& Determines whether libcurl verifies that the server cert is for the server it is known as.
	curloptsslverifypeer = .T.		&& This option determines whether curl verifies the authenticity of the peer's certificate.
	curloptsslversion = 0		&& Version of SSL/TLS to attempt to use.
	curlopttimeout = 0		&& Specifies the maximum time in seconds that you allow the libcurl transfer operation to take.
	curlopttransfertext = .F.		&& Use ASCII mode for ftp transfers.
	curloptunrestrictedauth = .F.		&& If TRUE, tells the library it can continue to send authentication (user+password) when following locations, even when hostname changed.
	curloptupload = .F.		&& Set to 1 to tell the library to prepare for an upload.
	curlopturl = 		&& The actual URL to deal with.
	curloptuseragent = 		&& Sets the User-Agent: header in http requests.
	curloptuserpwd = 		&& Set user name:password]to use for the connection.
	curloptusessl = 0
	curloptverbose = .F.		&& Set the parameter to 1 to get the library to display a lot of verbose information.
	ftpfilecount = 0
	Height = 23
	logfilename = 		&& Name of the log file.
	Name = "libcurl"
	Visible = .F.
	Width = 120
	_canceltransfer = .F.		&& This is set to TRUE by the CancelTTransfer Method.
	_databuffer = 		&& Buffer used to store received data
	_debugcallbackptr = 0
	_debugfilehandle = 0
	_ftpgetfeaturesdata = 
	_ftpgetfeaturesstatus = 0
	_headercallbackptr = 0
	_headerslist = 0
	_performlastcode = 0
	_performretcode = 0		&& Overrides the CurlEasyPerform return code with this value.
	_performstarttime = 0
	_postquoteslist = 0
	_prequoteslist = 0
	_progresscallbackptr = 0
	_progresscallbacktickcount = 0
	_quoteslist = 0
	_readcallbackptr = 0
	_seekcallbackptr = 0
	_writecallbackptr = 0

	ADD OBJECT 'lblname' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "libcurl", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,128, ;
		Height = 15, ;
		Left = 6, ;
		Name = "lblname", ;
		Top = 3, ;
		Width = 29
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE canceltransfer		&& This methd cancels the current transfer.
		*!* CancelTransfer()
		
		This._CancelTransfer = TRUE
		
	ENDPROC

	PROCEDURE curleasyescape
		*!* CurlEasyEscape
		
		Lparameters pcString
		
		Local ;
			lnResult As Integer, ;
			lcString As String
		
		m.lnResult = apiCurlEasyEscape(This.CurlEasyHandle, m.pcString, 0)
		
		*!* Use vfp2c32 to read string:
		m.lcString = ReadCString(m.lnResult)
		
		*!* Free memory:
		
		apiCurlFree(m.lnResult)
		
		Return m.lcString
		
	ENDPROC

	PROCEDURE curleasyperform		&& Perform a file transfer.
		*!* CurlEasyPerform
		
		*!* curl_easy_perform - Perform a file transfer 
		
		*!* CURLcode curl_easy_perform(CURL * handle )
		
		*!*	This function is called after the init and all the curl_easy_setopt(3) calls
		*!*	are made, and will perform the transfer as described in the options. It must
		*!*	be called with the same handle as input as the curl_easy_init call returned.
		
		*!*	You can do any amount of calls to curl_easy_perform(3) while using the same
		*!*	handle. If you intend to transfer more than one file, you are even encouraged
		*!*	to do so. libcurl will then attempt to re-use the same connection for the
		*!*	following transfers, thus making the operations faster, less CPU intense and
		*!*	using less network resources. Just note that you will have to use curl_easy_setopt(3)
		*!*	between the invokes to set options for the following curl_easy_perform.
		
		*!*	You must never call this function simultaneously from two places using the
		*!*	same handle. Let the function return first before invoking it another time.
		*!*	If you want parallel transfers, you must use several curl handles.
		
		Local lnReturn as Integer
		
		This._CancelTransfer = FALSE
		
		m.lnReturn = apiCurlEasyPerform(This.CurlEasyHandle)
		
		If This._PerformRetCode # 0 Then
			m.lnReturn = This._PerformRetCode
			This._PerformRetCode = 0
		Endif
		
		This._PerformLastCode = m.lnReturn
		
		Return m.lnReturn
		
	ENDPROC

	PROCEDURE curleasyreset		&& Reset all options of a libcurl session handle.
		*!* CurlEasyReset
		
		*!* curl_easy_reset - reset all options of a libcurl session handle 
		
		*!* void curl_easy_reset(CURL *handle )
		
		*!* Re-initializes all options previously set on a specified CURL handle 
		*!*	to the default values. This puts back the handle to the same state as 
		*!*	it was in when it was just created with curl_easy_init(3).
		
		*!*	It does not change the following information kept in the handle: live 
		*!*	connections, the Session ID cache, the DNS cache, the cookies and shares. 
		
		If This.CurlEasyHandle # 0 Then
			apiCurlEasyReset(This.CurlEasyHandle)
			
			*!* Reapply essential properties:
			This._SetDefaultProperties()
		Endif
		
	ENDPROC

	PROCEDURE curleasystrerror		&& Return string describing error code.
		*!* CurlEasyStrError
		
		*!* curl_easy_strerror - return string describing error code 
		
		*!* const char *curl_easy_strerror(CURLcode  errornum )
		
		*!* The curl_easy_strerror() function returns a string describing 
		*!* the CURLcode error code passed in the argument errornum. 
		
		Lparameters pnErrorNum
		
		If Vartype(m.pnErrorNum) = "N" Then
			Return apiCurlEasyStrError(m.pnErrorNum)
		Else
			Return apiCurlEasyStrError(This.CurlInfoPerformCode())
		Endif
		
	ENDPROC

	PROCEDURE curleasyunescape
		*!* CurlEasyUnescape
		
		Lparameters pcString
		
		Local ;
			lnOutLen As Integer, ;
			lnResult As Integer, ;
			lcString As String
		
		m.lnOutLen = 0
		
		m.lnResult = apiCurlEasyUnescape(This.CurlEasyHandle, m.pcString, 0, @m.lnOutLen)
		
		m.lcString = Sys(2600, m.lnResult, m.lnOutLen)
		
		apiCurlFree(m.lnResult)
		
		Return m.lcString
		
	ENDPROC

	PROCEDURE curlinfoeffectiveurl
		*!* CurlInfoEffectiveUrl()
		
		Local ;
			lnParam As Integer, ;
			lnResult As Integer
		
		m.lnParam = 0
		
		m.lnResult = apiCurlEasyGetInfoInteger(This.CurlEasyHandle, CURLINFO_EFFECTIVE_URL, @m.lnParam)
		
		If m.lnResult # CURLE_OK Then
			Return .Null.
		Endif
		
		Return ReadCString(m.lnParam)
		
		
	ENDPROC

	PROCEDURE curlinfoperformcode
		*!* CurlInfoPerformCode()
		
		*!*	This is not a native libcurl method, this is just to be able
		*!*	to get the last code from CurEasyPerform for methods that return
		*!*	TRUE/FALSE/STRING
		
		Return This._PerformLastCode
		
	ENDPROC

	PROCEDURE curlinforesponsecode
		*!* CurlInfoResponseCode()
		
		Local ;
			lnParam As Integer, ;
			lnResult As Integer
		
		m.lnParam = 0
		
		m.lnResult = apiCurlEasyGetInfoInteger(This.CurlEasyHandle, CURLINFO_RESPONSE_CODE , @m.lnParam)
		
		If m.lnResult = CURLE_OK Then
			Return m.lnParam
		Else
			Return 0
		Endif
		
	ENDPROC

	PROCEDURE curloptappend_assign
		*!* CurlOptAppend_Assign
		
		*!* A parameter set to 1 tells the library to append to the remote file 
		*!* instead of overwrite it. This is only useful when uploading to an ftp site. 
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptAppend = m.plValue
		
		m.lnOption = CURLOPT_APPEND
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
		
	ENDPROC

	PROCEDURE curloptautoreferer_assign
		*!* CurlOptAutoReferer_Assign
		
		*!*	Pass a parameter set to 1 to enable this. When enabled, libcurl will automatically 
		*!*	set the Referer: field in requests where it follows a Location: redirect. 
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptAutoReferer = m.plValue
		
		m.lnOption = CURLOPT_AUTOREFERER
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
	ENDPROC

	PROCEDURE curloptcookie_assign
		*!*	CurlOptCookie_Assign
		
		*!*	Pass a pointer to a zero terminated string as parameter. It will be used to 
		*!*	set a cookie in the http request. The format of the string should be NAME=CONTENTS, 
		*!*	where NAME is the cookie name and CONTENTS is what the cookie should contain.
		
		*!*	If you need to set multiple cookies, you need to set them all using a single 
		*!*	option and thus you need to concatenate them all in one single string. Set 
		*!*	multiple cookies in one string like this: "name1=content1; name2=content2;" etc.
		
		*!*	Note that this option sets the cookie header explictly in the outgoing request(s). 
		*!*	If multiple requests are done due to authentication, followed redirections or similar, 
		*!*	they will all get this cookie passed on.
		
		*!*	Using this option multiple times will only make the latest string override the previous ones. 
		
		Lparameters pcString
		
		This.CurlOptCookie = m.pcString
		
		If Empty(m.pcString) Then
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_COOKIE , 0)
		Else
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_COOKIE , m.pcString)
		Endif
		
	ENDPROC

	PROCEDURE curloptcopypostfields_assign
		*!*	CurlOptCopyPostFields_Assign
		
		*!*	Pass a char * as parameter, which should be the full data to post in an HTTP POST
		*!*	operation. It behaves as the CURLOPT_POSTFIELDS option, but the original data are
		*!*	copied by the library, allowing the application to overwrite the original data after
		*!*	setting this option.
		
		*!*	Because data are copied, care must be taken when using this option in conjunction
		*!*	with CURLOPT_POSTFIELDSIZE or CURLOPT_POSTFIELDSIZE_LARGE: If the size has not been
		*!*	set prior to CURLOPT_COPYPOSTFIELDS, the data are assumed to be a NUL-terminated
		*!*	string; else the stored size informs the library about the data byte count to copy.
		*!*	In any case, the size must not be changed after CURLOPT_COPYPOSTFIELDS, unless
		*!*	another CURLOPT_POSTFIELDS or CURLOPT_COPYPOSTFIELDS option is issued.
		
		Lparameters pcString
		
		This.CurlOptCopyPostFields = m.pcString
		
		If Empty(m.pcString) Then
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_COPYPOSTFIELDS, 0)
		Else
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_COPYPOSTFIELDS, m.pcString)
		Endif
		
	ENDPROC

	PROCEDURE curloptcrlf_assign
		*!* CurlOptCrlf_Assign
		
		*!* Convert Unix newlines to CRLF newlines on transfers. 
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptCrlf = m.plValue
		
		m.lnOption = CURLOPT_CRLF
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
	ENDPROC

	PROCEDURE curloptcustomrequest_assign
		*!*	CurlOptCustomRequest_Assign
		
		*!*	Pass a pointer to a zero terminated string as parameter. It will be used
		*!*	instead of GET or HEAD when doing an HTTP request, or instead of LIST
		*!*	or NLST when doing an ftp directory listing. This is useful for doing
		*!*	DELETE or other more or less obscure HTTP requests. Don't do this at
		*!*	will, make sure your server supports the command first.
		
		*!*	Note that libcurl will still act and assume the keyword it would use if
		*!*	you didn't set your custom one is the one in use and it will act according
		*!*	to that. Thus, changing this to a HEAD when libcurl otherwise would do a
		*!*	GET might cause libcurl to act funny, and similar. To switch to a proper
		*!*	HEAD, use CURLOPT_NOBODY, to switch to a proper POST, use CURLOPT_POST
		*!*	or CURLOPT_POSTFIELDS and so on.
		
		*!*	Restore to the internal default by setting this to NULL.
		
		*!*	Many people have wrongly used this option to replace the entire request 
		*!*	with their own, including multiple headers and POST contents. While that 
		*!*	might work in many cases, it will cause libcurl to send invalid requests 
		*!*	and it could possibly confuse the remote server badly. Use CURLOPT_POST 
		*!*	and CURLOPT_POSTFIELDS to set POST data. Use CURLOPT_HTTPHEADER to replace 
		*!*	or extend the set of headers sent by libcurl. Use CURLOPT_HTTP_VERSION 
		*!*	to change HTTP version. 
		
		Lparameters pcString
		
		This.CurlOptCustomRequest = m.pcString
		
		If Empty(m.pcString) Then
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_CUSTOMREQUEST, 0)
		Else
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_CUSTOMREQUEST, m.pcString)
		Endif
		
	ENDPROC

	PROCEDURE curloptdirlistonly_assign
		*!* CurlOptDirListOnly_Assign
		
		*!*	A parameter set to 1 tells the library to just list the names of 
		*!*	files in a directory, instead of doing a full directory listing 
		*!*	that would include file sizes, dates etc. This works for FTP and 
		*!*	SFTP URLs.
		
		*!*	This causes an FTP NLST command to be sent on an FTP server. Beware 
		*!*	that some FTP servers list only files in their response to NLST; 
		*!*	they might not include subdirectories and symbolic links. 
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptDirListOnly = m.plValue
		
		m.lnOption = CURLOPT_DIRLISTONLY
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
	ENDPROC

	PROCEDURE curloptfiletime_assign
		*!* CurlOptFileTime_Assign
		
		*!*	Pass a long. If it is 1, libcurl will attempt to get the modification 
		*!*	date of the remote document in this operation. This requires that the 
		*!*	remote server sends the time or replies to a time querying command. 
		*!*	The curl_easy_getinfo(3) function with the CURLINFO_FILETIME argument 
		*!*	can be used after a transfer to extract the received time (if any). 
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptFollowLocation = m.plValue
		
		m.lnOption = CURLOPT_FILETIME
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
	ENDPROC

	PROCEDURE curloptfollowlocation_assign
		*!* CurlOptFollowLocation_Assign
		
		*!*	A parameter set to 1 tells the library to follow any Location: 
		*!*	header that the server sends as part of an HTTP header.
		
		*!*	This means that the library will re-send the same request on the 
		*!*	new location and follow new Location: headers all the way until 
		*!*	no more such headers are returned. CURLOPT_MAXREDIRS can be used 
		*!*	to limit the number of redirects libcurl will follow. 
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptFollowLocation = m.plValue
		
		m.lnOption = CURLOPT_FOLLOWLOCATION
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
	ENDPROC

	PROCEDURE curloptftpaccount_assign
		*!*	CurlOptFtpAccount_Assign
		
		*!*	Pass a pointer to a zero-terminated string (or NULL to disable). 
		*!*	When an FTP server asks for "account data" after user name and password 
		*!*	has been provided, this data is sent off using the ACCT command. 
		
		Lparameters pcString
		
		This.CurlOptFtpAccount = m.pcString
		
		If Empty(m.pcString) Then
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_FTP_ACCOUNT, 0)
		Else
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_FTP_ACCOUNT, m.pcString)
		Endif
		
	ENDPROC

	PROCEDURE curloptftpcreatemissingdirs_assign
		*!* CurlOptFtpCreateMissingDirs_Assign
		
		*!*	Pass a long. If the value is 1, curl will attempt to create any 
		*!*	remote directory that it fails to CWD into. CWD is the command that 
		*!*	changes working directory. (Added in 7.10.7)
		
		*!*	This setting also applies to SFTP-connections. curl will attempt 
		*!*	to create the remote directory if it can't obtain a handle to the 
		*!*	target-location. The creation will fail if a file of the same name 
		*!*	as the directory to create already exists or lack of permissions 
		*!*	prevents creation. (Added in 7.16.3) 
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptFtpCreateMissingDirs = m.plValue
		
		m.lnOption = CURLOPT_FTP_CREATE_MISSING_DIRS
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
	ENDPROC

	PROCEDURE curloptftpfilemethod_assign
		*!* CurlOptFtpFileMethod_Assign
		
		*!*	Pass a long that should have one of the following values. This option controls 
		*!*	what method libcurl should use to reach a file on a FTP(S) server. The argument 
		*!*	should be one of the following alternatives:
		
		*!*	CURLFTPMETHOD_MULTICWD
		
		*!*	libcurl does a single CWD operation for each path part in the given URL. 
		*!*	For deep hierarchies this means very many commands. This is how RFC1738 says it 
		*!*	should be done. This is the default but the slowest behavior.
		
		*!*	CURLFTPMETHOD_NOCWD
		
		*!*	libcurl does no CWD at all. libcurl will do SIZE, RETR, STOR etc and give a 
		*!*	full path to the server for all these commands. This is the fastest behavior.
		
		*!*	CURLFTPMETHOD_SINGLECWD
		
		*!*	libcurl does one CWD with the full target directory and then operates on the file 
		*!*	"normally" (like in the multicwd case). This is somewhat more standards compliant 
		*!*	than 'nocwd' but without the full penalty of 'multicwd'. 
		*!*	Lparameters pnInteger
		
		Local lnOption As Integer
		
		This.CurlOptFtpFileMethod = m.pnInteger
		
		m.lnOption = CURLOPT_FTP_FILEMETHOD 
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
	ENDPROC

	PROCEDURE curloptftpport_assign
		*!*	CurlOptFtpPort_Assign
		
		*!*	Pass a pointer to a zero terminated string as parameter. It will be 
		*!*	used to get the IP address to use for the ftp PORT instruction. 
		*!*	The PORT instruction tells the remote server to connect to our specified 
		*!*	IP address. The string may be a plain IP address, a host name, an 
		*!*	network interface name (under Unix) or just a '-' letter to let the 
		*!*	library use your systems default IP address. Default FTP operations 
		*!*	are passive, and thus won't use PORT.
		
		*!*	You disable PORT again and go back to using the passive version by 
		*!*	setting this option to NULL. 
		
		Lparameters pcString
		
		This.CurlOptFtpPort = m.pcString
		
		If Empty(m.pcString) Then
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_FTPPORT, 0)
		Else
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_FTPPORT, m.pcString)
		Endif
		
	ENDPROC

	PROCEDURE curloptftpresponsetimeout_assign
		*!* CurlOptFtpResponseTimeout_Assign
		
		*!*	Pass a long. Causes curl to set a timeout period (in seconds) on 
		*!*	the amount of time that the server is allowed to take in order to 
		*!*	generate a response message for a command before the session is 
		*!*	considered hung. While curl is waiting for a response, this value 
		*!*	overrides CURLOPT_TIMEOUT. It is recommended that if used in 
		*!*	conjunction with CURLOPT_TIMEOUT, you set CURLOPT_FTP_RESPONSE_TIMEOUT 
		*!*	to a value smaller than CURLOPT_TIMEOUT. (Added in 7.10.8) 
		
		Lparameters pnInteger
		
		Local lnOption As Integer
		
		This.CurlOptFtpResponseTimeout = m.pnInteger
		
		m.lnOption = CURLOPT_FTP_RESPONSE_TIMEOUT
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
	ENDPROC

	PROCEDURE curloptftpsslauth_assign
		*!* CurlOptFtpSslAuth_Assign
		
		*!*	Pass a long using one of the values from below, to alter how libcurl 
		*!*	issues "AUTH TLS" or "AUTH SSL" when FTP over SSL is activated 
		*!*	(see CURLOPT_FTP_SSL). (Added in 7.12.2) 
		
		*!*	CURLFTPAUTH_DEFAULT
		*!* Allow libcurl to decide 
		
		*!*	CURLFTPAUTH_SSL
		*!* Try "AUTH SSL" first, and only if that fails try "AUTH TLS" 
		
		*!*	CURLFTPAUTH_TLS
		*!* Try "AUTH TLS" first, and only if that fails try "AUTH SSL" 
		
		Lparameters pnInteger
		
		Local lnOption As Integer
		
		This.CurlOptFtpSslAuth = m.pnInteger
		
		m.lnOption = CURLOPT_FTPSSLAUTH
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
	ENDPROC

	PROCEDURE curloptftpsslccc_assign
		*!* CurlOptFtpSslCcc_Assign
		
		*!*	If enabled, this option makes libcurl use CCC (Clear Command Channel). 
		*!*	It shuts down the SSL/TLS layer after authenticating. The rest of the 
		*!*	control channel communication will be unencrypted. This allows NAT 
		*!*	routers to follow the FTP transaction. Pass a long using one of the 
		*!*	values below. (Added in 7.16.1) 
		
		*!*	CURLFTPSSL_CCC_NONE
		*!* Don't attempt to use CCC. 
		
		*!*	CURLFTPSSL_CCC_PASSIVE
		*!* Do not initiate the shutdown, but wait for the server to do it. Do not send a reply. 
		
		*!*	CURLFTPSSL_CCC_ACTIVE
		*!* Initiate the shutdown and wait for a reply. 
		
		Lparameters pnInteger
		
		Local lnOption As Integer
		
		This.CurlOptFtpSslCcc = m.pnInteger
		
		m.lnOption = CURLOPT_FTP_SSL_CCC
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
	ENDPROC

	PROCEDURE curloptheader_assign
		*!* CurlOptHeader_Assign
		
		*!*	A parameter set to 1 tells the library to include the header in the body 
		*!*	output. This is only relevant for protocols that actually have headers 
		*!*	preceding the data (like HTTP). 
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptHeader = m.plValue
		
		m.lnOption = CURLOPT_HEADER
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
	ENDPROC

	PROCEDURE curlopthttpauth_assign
		*!* CurlOptHttpAuth_Assign
		
		*!*	Pass a long as parameter, which is set to a bitmask, to tell libcurl what 
		*!*	authentication method(s) you want it to use. The available bits are listed 
		*!*	below. If more than one bit is set, libcurl will first query the site to 
		*!*	see what authentication methods it supports and then pick the best one you 
		*!*	allow it to use. For some methods, this will induce an extra network round-trip. 
		*!*	Set the actual name and password with the CURLOPT_USERPWD option.
		
		*!*	CURLAUTH_BASIC
		
		*!*	HTTP Basic authentication. This is the default choice, and the only method 
		*!*	that is in wide-spread use and supported virtually everywhere. This is sending 
		*!*	the user name and password over the network in plain text, easily captured 
		*!*	by others.
		
		*!*	CURLAUTH_DIGEST
		
		*!*	HTTP Digest authentication. Digest authentication is defined in RFC2617 and is 
		*!*	a more secure way to do authentication over public networks than the regular 
		*!*	old-fashioned Basic method.
		
		*!*	CURLAUTH_GSSNEGOTIATE
		
		*!*	HTTP GSS-Negotiate authentication. The GSS-Negotiate (also known as plain 
		*!*	"Negotiate") method was designed by Microsoft and is used in their web 
		*!*	applications. It is primarily meant as a support for Kerberos5 authentication 
		*!*	but may be also used along with another authentication methods. For more 
		*!*	information see IETF draft draft-brezak-spnego-http-04.txt.
		
		*!*	You need to build libcurl with a suitable GSS-API library for this to work.
		
		*!*	CURLAUTH_NTLM
		
		*!*	HTTP NTLM authentication. A proprietary protocol invented and used by 
		*!*	Microsoft. It uses a challenge-response and hash concept similar to Digest, 
		*!*	to prevent the password from being eavesdropped.
		
		*!*	You need to build libcurl with OpenSSL support for this option to work, or 
		*!*	build libcurl on Windows.
		
		*!*	CURLAUTH_ANY
		
		*!*	This is a convenience macro that sets all bits and thus makes libcurl pick 
		*!*	any it finds suitable. libcurl will automatically select the one it finds 
		*!*	most secure.
		
		*!*	CURLAUTH_ANYSAFE
		
		*!*	This is a convenience macro that sets all bits except Basic and thus makes 
		*!*	libcurl pick any it finds suitable. libcurl will automatically select the 
		*!*	one it finds most secure. 
		*!*	Lparameters pnInteger
		
		Lparameters pnInteger
		
		Local lnOption As Integer
		
		This.CurlOptHttpAuth = m.pnInteger
		
		m.lnOption = CURLOPT_HTTPAUTH
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
	ENDPROC

	PROCEDURE curlopthttpget_assign
		*!* CurlOptHttpGet_Assign
		
		*!*	Pass a long. If the long is 1, this forces the HTTP request to get back to GET. 
		*!*	usable if a POST, HEAD, PUT or a custom request have been used previously using 
		*!*	the same curl handle.
		
		*!*	When setting CURLOPT_HTTPGET to 1, it will automatically set CURLOPT_NOBODY to 0
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptHttpGet = m.plValue
		
		m.lnOption = CURLOPT_HTTPGET
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
	ENDPROC

	PROCEDURE curlopthttpheader_assign
		*!* CurlOptHttpHeader_Assign
		
		*!*	Pass a pointer to a linked list of HTTP headers to pass to the server in
		*!*	your HTTP request. The linked list should be a fully valid list of struct
		*!*	curl_slist structs properly filled in. Use curl_slist_append(3) to create
		*!*	the list and curl_slist_free_all(3) to clean up an entire list. If you add
		*!*	a header that is otherwise generated and used by libcurl internally, your
		*!*	added one will be used instead. If you add a header with no contents as in
		*!*	'Accept:' (no data on the right side of the colon), the internally used header
		*!*	will get disabled. Thus, using this option you can add new headers, replace
		*!*	internal headers and remove internal headers. To add a header with no contents,
		*!*	make the contents be two quotes: "". The headers included in the linked list
		*!*	must not be CRLF-terminated, because curl adds CRLF after each header item.
		*!*	Failure to comply with this will result in strange bugs because the server
		*!*	will most likely ignore part of the headers you specified.
		
		*!*	The first line in a request (containing the method, usually a GET or POST)
		*!*	is not a header and cannot be replaced using this option. Only the lines
		*!*	following the request-line are headers. Adding this method line in this list
		*!*	of headers will only cause your request to send an invalid header.
		
		*!*	Pass a NULL to this to reset back to no custom headers.
		
		*!*	The most commonly replaced headers have "shortcuts" in the options CURLOPT_COOKIE,
		*!*	CURLOPT_USERAGENT and CURLOPT_REFERER.
		
		Lparameters pcString
		
		Local lnx As Integer
		
		This.CurlOptHttpHeader = m.pcString
		
		*!* Release any previous curl slist
		If This._HeaderSlist # 0 Then
			apiCurlSlistFreeAll(This._HeaderSlist)
			This._HeaderSlist = 0
		Endif
		
		If Not Empty(m.pcString) Then
			For m.lnx = 1 To Getwordcount(m.pcString, "|")
				This._HeaderSlist = apiCurlSlistAppend(This._HeaderSlist, Getwordnum(m.pcString, m.lnx, "|"))
			Endfor
		Endif
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_HTTPHEADER, This._HeaderSlist)
		
	ENDPROC

	PROCEDURE curlopthttpproxytunnel_assign
		*!* CurlOptHttpProxyTunnel_Assign
		
		*!*	Set the parameter to 1 to make the library tunnel all operations 
		*!*	through a given HTTP proxy. There is a big difference between using 
		*!*	a proxy and to tunnel through it. If you don't know what this means, 
		*!*	you probably don't want this tunneling option. 
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptHttpProxyTunnel = m.plValue
		
		m.lnOption = CURLOPT_HTTPPROXYTUNNEL
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
	ENDPROC

	PROCEDURE curloptinterface_assign
		*!*	CurlOptInterface_Assign
		
		*!*	Pass a char * as parameter. This set the interface name to use as outgoing network
		*!*	interface. The name can be an interface name, an IP address or a host name. 
		
		Lparameters pcString
		
		This.CurlOptInterface = m.pcString
		
		If Empty(m.pcString) Then
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_INTERFACE, 0)
		Else
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_INTERFACE, m.pcString)
		Endif
		
	ENDPROC

	PROCEDURE curloptlocalportrange_assign
		*!* CurlOptLocalPortRange_Assign
		
		*!*	Pass a long. This is the number of attempts libcurl should do to find a working 
		*!*	local port number. It starts with the given CURLOPT_LOCALPORT and adds one to 
		*!*	the number for each retry. Setting this to 1 or below will make libcurl do only 
		*!*	one try for the exact port number. Note that port numbers by nature are scarce 
		*!*	resources that will be busy at times so setting this value to something too low 
		*!*	might cause unnecessary connection setup failures. (Added in 7.15.2) 
		*!*	Lparameters pnInteger
		
		Local lnOption As Integer
		
		This.CurlOptLocalPortRange = m.pnInteger
		
		m.lnOption = CURLOPT_LOCALPORTRANGE
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
	ENDPROC

	PROCEDURE curloptlocalport_assign
		*!* CurlOptLocalPort_Assign
		
		*!*	Pass a long. This sets the local port number of the socket used for connection. 
		*!*	This can be used in combination with CURLOPT_INTERFACE and you are recommended 
		*!*	to use CURLOPT_LOCALPORTRANGE as well when this is set. Note that port numbers 
		*!*	are only valid 1 - 65535. (Added in 7.15.2) 
		
		Lparameters pnInteger
		
		Local lnOption As Integer
		
		This.CurlOptLocalPort = m.pnInteger
		
		m.lnOption = CURLOPT_LOCALPORT 
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
	ENDPROC

	PROCEDURE curloptmaxrecvspeed_assign
		*!* CurlOptMaxRecvSpeed_Assign
		
		*!*	Pass a curl_off_t as parameter. If a download exceeds this speed on cumulative 
		*!*	average during the transfer, the transfer will pause to keep the average rate 
		*!*	less than or equal to the parameter value. Defaults to unlimited speed. (Added in 7.15.5) 
		
		Lparameters pnInteger
		
		Local ;
			lnOption As Integer, ;
			lnLo As Integer, ;
			lnHi As Integer
		
		This.CurlOptMaxRecvSpeed = m.pnInteger
		
		*!* Split into Int64 Low and High parts:
		m.lnLo = m.pnInteger % 2^32
		m.lnHi = Int((m.pnInteger - m.lnLo) / 2^32)
		
		If m.lnLo < 0 Then
			m.lnLo = m.lnLo + 2^32
		Endif
		
		m.lnOption = CURLOPT_MAX_RECV_SPEED_LARGE
		
		apiCurlEasySetOptInt64(This.CurlEasyHandle, m.lnOption, m.lnLo, m.lnHi)
		
	ENDPROC

	PROCEDURE curloptmaxredirs_assign
		*!* CurlOptMaxRedirs_Assign
		
		*!*	Pass a long. The set number will be the redirection limit. If that many redirections 
		*!*	have been followed, the next redirect will cause an error (CURLE_TOO_MANY_REDIRECTS). 
		*!*	This option only makes sense if the CURLOPT_FOLLOWLOCATION is used at the same time. 
		*!*	Added in 7.15.1: Setting the limit to 0 will make libcurl refuse any redirect. Set it 
		*!*	to -1 for an infinite number of redirects (which is the default) 
		
		Lparameters pnInteger
		
		Local lnOption As Integer
		
		This.CurlOptMaxRedirs = m.pnInteger
		
		m.lnOption = CURLOPT_MAXREDIRS 
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
	ENDPROC

	PROCEDURE curloptmaxsendspeed_assign
		*!* CurlOptMaxSendSpeed_Assign
		
		*!*	Pass a curl_off_t as parameter. If a download exceeds this speed on cumulative 
		*!*	average during the transfer, the transfer will pause to keep the average rate 
		*!*	less than or equal to the parameter value. Defaults to unlimited speed. (Added in 7.15.5) 
		
		Lparameters pnInteger
		
		Local ;
			lnOption As Integer, ;
			lnLo As Integer, ;
			lnHi As Integer
		
		This.CurlOptMaxSendSpeed = m.pnInteger
		
		*!* Split into Int64 Low and High parts:
		m.lnLo = m.pnInteger % 2^32
		m.lnHi = Int((m.pnInteger - m.lnLo) / 2^32)
		
		If m.lnLo < 0 Then
			m.lnLo = m.lnLo + 2^32
		Endif
		
		m.lnOption = CURLOPT_MAX_SEND_SPEED_LARGE
		
		apiCurlEasySetOptInt64(This.CurlEasyHandle, m.lnOption, m.lnLo, m.lnHi)
		
	ENDPROC

	PROCEDURE curloptnobody_assign
		*!* CurlOptNoBody_Assign
		
		*!*	A parameter set to 1 tells the library to not include the body-part 
		*!*	in the output. This is only relevant for protocols that have separate 
		*!*	header and body parts. On HTTP(S) servers, this will make libcurl do 
		*!*	a HEAD request.
		
		*!*	To change request to GET, you should use CURLOPT_HTTPGET. 
		*!*	Change request to POST with CURLOPT_POST etc. 
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptNoBody = m.plValue
		
		m.lnOption = CURLOPT_NOBODY
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
	ENDPROC

	PROCEDURE curloptport_assign
		*!* CurlOptPort_Assign
		
		*!*	Pass a long specifying what remote port number to connect to, 
		*!*	instead of the one specified in the URL or the default port 
		*!*	for the used protocol. 
		
		Lparameters pnInteger
		
		Local lnOption As Integer
		
		This.CurlOptPort = m.pnInteger
		
		m.lnOption = CURLOPT_PORT
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
	ENDPROC

	PROCEDURE curloptpost301_assign
		*!* CurlOptPost301_Assign
		
		*!*	A parameter set to 1 tells the library to respect RFC 2616/10.3.2 and not convert 
		*!*	POST requests into GET requests when following a 301 redirection. The non-RFC 
		*!*	behaviour is ubiquitous in web browsers, so the library does the conversion by 
		*!*	default to maintain consistency. However, a server may requires a POST to remain 
		*!*	a POST after such a redirection. This option is meaningful only when setting 
		*!*	CURLOPT_FOLLOWLOCATION. (Added in 7.17.1) 
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptPost301 = m.plValue
		
		m.lnOption = CURLOPT_POST301
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
	ENDPROC

	PROCEDURE curloptpostfieldsize_assign
		*!* CurlOptPostFieldSize_Assign
		
		*!*	If you want to post data to the server without letting libcurl do a strlen() 
		*!*	to measure the data size, this option must be used. When this option is used 
		*!*	you can post fully binary data, which otherwise is likely to fail. If this size 
		*!*	is set to -1, the library will use strlen() to get the size. 
		
		Lparameters pnInteger
		
		Local lnOption As Integer
		
		This.CurlOptPostFieldSize = m.pnInteger
		
		m.lnOption = CURLOPT_POSTFIELDSIZE
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
	ENDPROC

	PROCEDURE curloptpostquote_assign
		*!* CurlOptPostQuote_Assign
		
		*!*	Pass a pointer to a linked list of FTP or SFTP commands to pass to the 
		*!*	server after your ftp transfer request. The linked list should be a fully 
		*!*	valid list of struct curl_slist structs properly filled in as described 
		*!*	for CURLOPT_QUOTE. Disable this operation again by setting a NULL to this option. 
		
		*!* This is wrapped in this way:
		*!* Just pass a string containing the commands, separated by "|"
		
		Lparameters pcString
		
		Local lnx
		
		This.CurlOptPostQuote = m.pcString
		
		*!* Release any previous curl slist
		If This._PostQuoteSlist # 0 Then
			apiCurlSlistFreeAll(This._PostQuoteSlist)
			This._PostQuoteSlist = 0
		Endif
		
		If Not Empty(m.pcString) Then
			For m.lnx = 1 To Getwordcount(m.pcString, "|")
				This._PostQuoteSlist = apiCurlSlistAppend(This._PostQuoteSlist, Getwordnum(m.pcString, m.lnx, "|"))
			Endfor
		Endif
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_POSTQUOTE, This._PostQuoteSlist)
		
		
		
	ENDPROC

	PROCEDURE curloptpost_assign
		*!* CurlOptPost_Assign
		
		*!*	A parameter set to 1 tells the library to do a regular HTTP post. This will 
		*!*	also make the library use a "Content-Type: application/x-www-form-urlencoded" 
		*!*	header. (This is by far the most commonly used POST method).
		
		*!*	Use one of CURLOPT_POSTFIELDS or CURLOPT_COPYPOSTFIELDS options to specify 
		*!*	what data to post and CURLOPT_POSTFIELDSIZE or CURLOPT_POSTFIELDSIZE_LARGE 
		*!*	to set the data size.
		
		*!*	Optionally, you can provide data to POST using the CURLOPT_READFUNCTION and 
		*!*	CURLOPT_READDATA options but then you must make sure to not set CURLOPT_POSTFIELDS 
		*!*	to anything but NULL. When providing data with a callback, you must transmit it 
		*!*	using chunked transfer-encoding or you must set the size of the data with the 
		*!*	CURLOPT_POSTFIELDSIZE or CURLOPT_POSTFIELDSIZE_LARGE option. To enable chunked 
		*!*	encoding, you simply pass in the appropriate Transfer-Encoding header, see the 
		*!*	post-callback.c example.
		
		*!*	You can override the default POST Content-Type: header by setting your own with 
		*!*	CURLOPT_HTTPHEADER.
		
		*!*	Using POST with HTTP 1.1 implies the use of a "Expect: 100-continue" header. 
		*!*	You can disable this header with CURLOPT_HTTPHEADER as usual.
		
		*!*	If you use POST to a HTTP 1.1 server, you can send data without knowing the size 
		*!*	before starting the POST if you use chunked encoding. You enable this by adding a 
		*!*	header like "Transfer-Encoding: chunked" with CURLOPT_HTTPHEADER. With HTTP 1.0 or 
		*!*	without chunked transfer, you must specify the size in the request.
		
		*!*	When setting CURLOPT_POST to 1, it will automatically set CURLOPT_NOBODY to 0 (since 7.14.1).
		
		*!*	If you issue a POST request and then want to make a HEAD or GET using the same 
		*!*	re-used handle, you must explicitly set the new request type using CURLOPT_NOBODY 
		*!*	or CURLOPT_HTTPGET or similar. 
		
		*!* Here we will use the read callback to send the data, setting CURLOPT_POSTFIELDSIZE 
		*!* TODO: add HttpPostFile and HttpPostString methods.
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptPost = m.plValue
		
		m.lnOption = CURLOPT_POST
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
	ENDPROC

	PROCEDURE curloptprequote_assign
		*!*	CurlOptPreQuote_Assign
		
		*!*	Pass a pointer to a linked list of FTP commands to pass to the server 
		*!*	after the transfer type is set. The linked list should be a fully valid 
		*!*	list of struct curl_slist structs properly filled in as described for 
		*!*	CURLOPT_QUOTE. Disable this operation again by setting a NULL to this 
		*!*	option. Before version 7.15.6, if you also set CURLOPT_NOBODY to 1, 
		*!*	this option didn't work. 
		
		*!* This is wrapped in this way:
		*!* Just pass a string containing the commands, separated by "|"
		
		Lparameters pcString
		Local lnx
		
		This.CurlOptPreQuote = m.pcString
		
		*!* Release any previous curl slist
		If This._PreQuoteSlist # 0 Then
			apiCurlSlistFreeAll(This._PreQuoteSlist)
			This._PreQuoteSlist = 0
		Endif
		
		If Not Empty(m.pcString) Then
			For m.lnx = 1 To Getwordcount(m.pcString, "|")
				This._PreQuoteSlist = apiCurlSlistAppend(This._PreQuoteSlist , Getwordnum(m.pcString, m.lnx, "|"))
			Endfor
		Endif
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_PREQUOTE, This._PreQuoteSlist )
		
	ENDPROC

	PROCEDURE curloptprogress_assign
		*!* CurlOptProgress_Assign
		
		*!* Instead of using CURLOPT_NOPROGRESS we call this property CurlOptProgress
		*!* and reverse the value of CURLOPT_NOPROGRESS 
		
		*!* CURLOPT_NOPROGRESS is 1 by default, CurlOptProgress is 0 by default
		
		*!* CURLOPT_NOPROGRESS set to 1 tells the library to shut off the built-in progress meter completely. 
		
		*!* CurlOptProgress set to 1 fires the TransferProgress event about once every second
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptProgress = m.plValue
		
		m.lnOption = CURLOPT_NOPROGRESS
		
		m.lnParam = Iif(m.plValue, 0, 1)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
		If This.CurlOptProgress = TRUE Then
			apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_PROGRESSFUNCTION, This._ProgressCallBackPtr)
			apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_PROGRESSDATA, 0)
		Else
			apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_PROGRESSFUNCTION, 0)
		Endif
		
		
		
	ENDPROC

	PROCEDURE curloptproxyauth_assign
		*!* CurlOptProxyAuth_Assign
		
		*!*	Pass a long as parameter, which is set to a bitmask, to tell libcurl 
		*!*	what authentication method(s) you want it to use for your proxy 
		*!*	authentication. If more than one bit is set, libcurl will first query 
		*!*	the site to see what authentication methods it supports and then pick 
		*!*	the best one you allow it to use. For some methods, this will induce 
		*!*	an extra network round-trip. Set the actual name and password with 
		*!*	the CURLOPT_PROXYUSERPWD option. The bitmask can be constructed by 
		*!*	or'ing together the bits listed above for the CURLOPT_HTTPAUTH option. 
		*!*	As of this writing, only Basic, Digest and NTLM work. (Added in 7.10.7) 
		
		*!*	CURLAUTH_BASIC
		
		*!*	HTTP Basic authentication. This is the default choice, and the only method 
		*!*	that is in wide-spread use and supported virtually everywhere. This is 
		*!*	sending the user name and password over the network in plain text, easily 
		*!*	captured by others.
		
		*!*	CURLAUTH_DIGEST
		
		*!*	HTTP Digest authentication. Digest authentication is defined in RFC2617 and 
		*!*	is a more secure way to do authentication over public networks than the 
		*!*	regular old-fashioned Basic method.
		
		*!*	CURLAUTH_GSSNEGOTIATE
		
		*!*	HTTP GSS-Negotiate authentication. The GSS-Negotiate (also known as plain 
		*!*	"Negotiate") method was designed by Microsoft and is used in their web 
		*!*	applications. It is primarily meant as a support for Kerberos5 authentication 
		*!*	but may be also used along with another authentication methods. For more 
		*!*	information see IETF draft draft-brezak-spnego-http-04.txt.
		
		*!*	You need to build libcurl with a suitable GSS-API library for this to work.
		
		*!*	CURLAUTH_NTLM
		
		*!*	HTTP NTLM authentication. A proprietary protocol invented and used by Microsoft. 
		*!*	It uses a challenge-response and hash concept similar to Digest, to prevent 
		*!*	the password from being eavesdropped.
		
		*!*	You need to build libcurl with OpenSSL support for this option to work, or 
		*!*	build libcurl on Windows.
		
		*!*	CURLAUTH_ANY
		
		*!*	This is a convenience macro that sets all bits and thus makes libcurl pick any 
		*!*	it finds suitable. libcurl will automatically select the one it finds most secure.
		
		*!*	CURLAUTH_ANYSAFE
		
		*!*	This is a convenience macro that sets all bits except Basic and thus makes 
		*!*	libcurl pick any it finds suitable. libcurl will automatically select the one 
		*!*	it finds most secure. 
		*!*	Lparameters pnInteger
		
		Lparameters pnInteger
		
		Local lnOption As Integer
		
		This.CurlOptProxyAuth = m.pnInteger
		
		m.lnOption = CURLOPT_PROXYAUTH
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
	ENDPROC

	PROCEDURE curloptproxyport_assign
		*!* CurlOptProxyPort_Assign
		
		*!*	Pass a long with this option to set the proxy port to connect to 
		*!*	unless it is specified in the proxy string CURLOPT_PROXY. 
		
		Lparameters pnInteger
		
		Local lnOption As Integer
		
		This.CurlOptProxyPort = m.pnInteger
		
		m.lnOption = CURLOPT_PROXYPORT
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
	ENDPROC

	PROCEDURE curloptproxytype_assign
		*!* CurlOptProxyType_Assign
		
		*!*	Pass a long with this option to set type of the proxy. Available options 
		*!*	for this are CURLPROXY_HTTP, CURLPROXY_SOCKS4 (added in 7.15.2), 
		*!*	CURLPROXY_SOCKS5, CURLPROXY_SOCKS4A (added in 7.18.0) and 
		*!*	CURLPROXY_SOCKS5_HOSTNAME (added in 7.18.0). The HTTP type is default. 
		*!*	(Added in 7.10) 
		
		*!*	CURLPROXY_HTTP
		*!*	CURLPROXY_SOCKS4
		*!*	CURLPROXY_SOCKS5
		*!*	CURLPROXY_SOCKS4A
		*!*	CURLPROXY_SOCKS5_HOSTNAME
		
		Lparameters pnInteger
		
		Local lnOption As Integer
		
		This.CurlOptProxyType = m.pnInteger
		
		m.lnOption = CURLOPT_PROXYTYPE
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
	ENDPROC

	PROCEDURE curloptproxyuserpwd_assign
		*!*	CurlOptProxyUserPwd_Assign
		
		*!*	Pass a char * as parameter, which should be [user name]:[password] 
		*!*	to use for the connection to the HTTP proxy. Use CURLOPT_PROXYAUTH 
		*!*	to decide authentication method. 
		
		Lparameters pcString
		
		This.CurlOptProxyUserPwd = m.pcString
		
		If Empty(m.pcString) Then
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_PROXYUSERPWD, 0)
		Else
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_PROXYUSERPWD, m.pcString)
		Endif
		
	ENDPROC

	PROCEDURE curloptproxy_assign
		*!*	CurlOptProxy_Assign
		
		*!*	Set HTTP proxy to use. The parameter should be a char * to a zero terminated 
		*!*	string holding the host name or dotted IP address. To specify port number in 
		*!*	this string, append :[port] to the end of the host name. The proxy string may 
		*!*	be prefixed with [protocol]:// since any such prefix will be ignored. The 
		*!*	proxy's port number may optionally be specified with the separate option 
		*!*	CURLOPT_PROXYPORT.
		
		*!*	When you tell the library to use an HTTP proxy, libcurl will transparently 
		*!*	convert operations to HTTP even if you specify an FTP URL etc. This may have 
		*!*	an impact on what other features of the library you can use, such as CURLOPT_QUOTE 
		*!*	and similar FTP specifics that don't work unless you tunnel through the HTTP 
		*!*	proxy. Such tunneling is activated with CURLOPT_HTTPPROXYTUNNEL.
		
		*!*	libcurl respects the environment variables http_proxy, ftp_proxy, all_proxy etc, 
		*!*	if any of those is set. The CURLOPT_PROXY option does however override any 
		*!*	possibly set environment variables.
		
		*!*	Setting the proxy string to "" (an empty string) will explicitly disable the 
		*!*	use of a proxy, even if there is an environment variable set for it.
		
		*!*	Since 7.14.1, the proxy host string given in environment variables can be 
		*!*	specified the exact same way as the proxy can be set with CURLOPT_PROXY, 
		*!*	include protocol prefix (http://) and embedded user + password. 
		
		Lparameters pcString
		
		This.CurlOptProxy = m.pcString
		
		If Empty(m.pcString) Then
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_PROXY, 0)
		Else
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_PROXY, m.pcString)
		Endif
		
	ENDPROC

	PROCEDURE curloptquote_assign
		*!*	CurlOptQuote_Assign
		
		*!*	Pass a pointer to a linked list of FTP or SFTP commands to pass to the 
		*!*	server prior to your ftp request. This will be done before any other 
		*!*	commands are issued (even before the CWD command for FTP). The linked 
		*!*	list should be a fully valid list of 'struct curl_slist' structs properly 
		*!*	filled in with text strings. Use curl_slist_append(3) to append strings 
		*!*	(commands) to the list, and clear the entire list afterwards with 
		*!*	curl_slist_free_all(3). Disable this operation again by setting a NULL 
		*!*	to this option. The set of valid FTP commands depends on the server 
		*!*	(see RFC959 for a list of mandatory commands). The valid SFTP commands 
		*!*	are: chgrp, chmod, chown, ln, mkdir, pwd, rename, rm, rmdir, symlink 
		*!*	(see curl (1)) (SFTP support added in 7.16.3) 
		
		*!* This is wrapped in this way:
		*!* Just pass a string containing the commands, separated by "|"
		
		Lparameters pcString
		Local lnx
		
		This.CurlOptQuote = m.pcString
		
		*!* Release any previous curl slist
		If This._QuoteSlist # 0 Then
			apiCurlSlistFreeAll(This._QuoteSlist)
			This._QuoteSlist = 0
		Endif
		
		If Not Empty(m.pcString) Then
			For m.lnx = 1 To Getwordcount(m.pcString, "|")
				This._QuoteSlist = apiCurlSlistAppend(This._QuoteSlist, Getwordnum(m.pcString, m.lnx, "|"))
			Endfor
		Endif
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_QUOTE, This._QuoteSlist)
		
	ENDPROC

	PROCEDURE curloptrange_assign
		*!*	CurlOptRange_Assign
		
		*!*	Pass a char * as parameter, which should contain the specified range 
		*!*	you want. It should be in the format "X-Y", where X or Y may be left 
		*!*	out. HTTP transfers also support several intervals, separated with 
		*!*	commas as in "X-Y,N-M". Using this kind of multiple intervals will 
		*!*	cause the HTTP server to send the response document in pieces (using 
		*!*	standard MIME separation techniques). Pass a NULL to this option to 
		*!*	disable the use of ranges.
		
		*!*	Ranges work on HTTP, FTP and FILE (since 7.18.0) transfers only. 
		
		Lparameters pcString
		
		This.CurlOptRange = m.pcString
		
		If Empty(m.pcString) Then
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_RANGE, 0)
		Else
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_RANGE, m.pcString)
		Endif
		
	ENDPROC

	PROCEDURE curloptreferer_assign
		*!*	CurlOptReferer_Assign
		
		*!*	Pass a pointer to a zero terminated string as parameter. It will be used to 
		*!*	set the Referer: header in the http request sent to the remote server. 
		
		*!*	This can be used to fool servers or scripts. You can also set any custom 
		*!*	header with CURLOPT_HTTPHEADER. 
		
		Lparameters pcString
		
		This.CurlOptReferer = m.pcString
		
		If Empty(m.pcString) Then
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_REFERER, 0)
		Else
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_REFERER, m.pcString)
		Endif
		
	ENDPROC

	PROCEDURE curloptresumefrom_assign
		*!* CurlOptResumeFrom_Assign
		
		*!*	Pass a long as parameter. It contains the offset in number of bytes that
		*!*	you want the transfer to start from. Set this option to 0 to make the
		*!*	transfer start from the beginning (effectively disabling resume). For
		*!*	FTP, set this option to -1 to make the transfer start from the end of
		*!*	the target file (useful to continue an interrupted upload).
		
		Lparameters pnInteger
		
		Local ;
			lnOption As Integer, ;
			lnLo As Integer, ;
			lnHi As Integer
		
		This.CurlOptResumeFrom = m.pnInteger
		
		If m.pnInteger = -1 Then
		
			m.lnOption = CURLOPT_RESUME_FROM
			apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
		Else
		
			*!* Split into Int64 Low and High parts:
			m.lnLo = m.pnInteger % 2^32
			m.lnHi = Int((m.pnInteger - m.lnLo) / 2^32)
		
			If m.lnLo < 0 Then
				m.lnLo = m.lnLo + 2^32
			Endif
		
			m.lnOption = CURLOPT_RESUME_FROM_LARGE
			apiCurlEasySetOptInt64(This.CurlEasyHandle, m.lnOption, m.lnLo, m.lnHi)
		
		Endif
		
		
	ENDPROC

	PROCEDURE curloptsslverifyhost_assign
		*!*	CurlOptSslVerifyHost_Assign
		
		
		*!*	Pass a long as parameter.
		
		*!*	This option determines whether libcurl verifies that the server cert 
		*!*	is for the server it is known as.
		
		*!*	When negotiating an SSL connection, the server sends a certificate 
		*!*	indicating its identity.
		
		*!*	When CURLOPT_SSL_VERIFYHOST is 2, that certificate must indicate that 
		*!*	the server is the server to which you meant to connect, or the connection fails.
		
		*!*	Curl considers the server the intended one when the Common Name field 
		*!*	or a Subject Alternate Name field in the certificate matches the host 
		*!*	name in the URL to which you told Curl to connect.
		
		*!*	When the value is 1, the certificate must contain a Common Name field, 
		*!*	but it doesn't matter what name it says. (This is not ordinarily a useful setting).
		
		*!*	When the value is 0, the connection succeeds regardless of the names in the certificate.
		
		*!*	The default, since 7.10, is 2.
		
		*!*	The checking this option controls is of the identity that the server claims. 
		*!*	The server could be lying. To control lying, see CURLOPT_SSL_VERIFYPEER. 
		
		Lparameters pnInteger
		
		Local lnOption As Integer
		
		This.CurlOptSslVerifyHost = m.pnInteger
		
		m.lnOption = CURLOPT_SSL_VERIFYHOST
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
	ENDPROC

	PROCEDURE curloptsslverifypeer_assign
		*!*	CurlOptSslVerifyPeer_Assign
		
		*!*	This option determines whether curl verifies the authenticity of the peer's certificate.
		*!*	A value of 1 means curl verifies; zero means it doesn't. The default is nonzero, but
		*!*	before 7.10, it was zero.
		
		*!*	When negotiating an SSL connection, the server sends a certificate indicating its identity.
		*!*	Curl verifies whether the certificate is authentic, i.e. that you can trust that the server
		*!*	is who the certificate says it is. This trust is based on a chain of digital signatures,
		*!*	rooted in certification authority (CA) certificates you supply. As of 7.10, curl installs
		*!*	a default bundle of CA certificates and you can specify alternate certificates with the
		*!*	CURLOPT_CAINFO option or the CURLOPT_CAPATH option.
		
		*!*	When CURLOPT_SSL_VERIFYPEER is nonzero, and the verification fails to prove that the
		*!*	certificate is authentic, the connection fails. When the option is zero, the connection
		*!*	succeeds regardless.
		
		*!*	Authenticating the certificate is not by itself very useful. You typically want to ensure
		*!*	that the server, as authentically identified by its certificate, is the server you mean to
		*!*	be talking to. Use CURLOPT_SSL_VERIFYHOST to control that.
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptSslVerifyPeer = m.plValue
		
		m.lnOption = CURLOPT_SSL_VERIFYPEER
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
		
	ENDPROC

	PROCEDURE curloptsslversion_assign
		*!*	CurlOptSslVersion_Assign
		
		*!*	Pass a long as parameter to control what version of SSL/TLS to attempt to use. 
		*!*	The available options are:
		
		*!*	CURL_SSLVERSION_DEFAULT
		
		*!*	The default action. This will attempt to figure out the remote SSL protocol version, 
		*!*	i.e. either SSLv3 or TLSv1 (but not SSLv2, which became disabled by default with 7.18.1).
		
		*!*	CURL_SSLVERSION_TLSv1
		
		*!*	Force TLSv1
		
		*!*	CURL_SSLVERSION_SSLv2
		
		*!*	Force SSLv2
		
		*!*	CURL_SSLVERSION_SSLv3
		
		*!*	Force SSLv3
		
		*!*	CURLOPT_SSL_VERIFYPEER
		
		*!*	Pass a long as parameter.
		
		*!*	This option determines whether curl verifies the authenticity of the peer's certificate. 
		*!*	A value of 1 means curl verifies; zero means it doesn't. The default is nonzero, but before 
		*!*	7.10, it was zero.
		
		*!*	When negotiating an SSL connection, the server sends a certificate indicating its identity. 
		*!*	Curl verifies whether the certificate is authentic, i.e. that you can trust that the server 
		*!*	is who the certificate says it is. This trust is based on a chain of digital signatures, 
		*!*	rooted in certification authority (CA) certificates you supply. As of 7.10, curl installs 
		*!*	a default bundle of CA certificates and you can specify alternate certificates with the 
		*!*	CURLOPT_CAINFO option or the CURLOPT_CAPATH option.
		
		*!*	When CURLOPT_SSL_VERIFYPEER is nonzero, and the verification fails to prove that the 
		*!*	certificate is authentic, the connection fails. When the option is zero, the connection 
		*!*	succeeds regardless.
		
		*!*	Authenticating the certificate is not by itself very useful. You typically want to ensure 
		*!*	that the server, as authentically identified by its certificate, is the server you mean to 
		*!*	be talking to. Use CURLOPT_SSL_VERIFYHOST to control that. 
		
		Lparameters pnInteger
		
		Local lnOption As Integer
		
		This.CurlOptSslVersion = m.pnInteger
		
		m.lnOption = CURLOPT_SSLVERSION
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
	ENDPROC

	PROCEDURE curlopttimeout_assign
		*!* CurlOptTimeOut_Assign
		
		*!*	Pass a long as parameter containing the maximum time in seconds that you
		*!*	allow the libcurl transfer operation to take. Normally, name lookups can
		*!*	take a considerable time and limiting operations to less than a few minutes
		*!*	risk aborting perfectly normal operations. This option will cause curl to
		*!*	use the SIGALRM to enable time-outing system calls.
		
		*!*	In unix-like systems, this might cause signals to be used unless
		*!*	CURLOPT_NOSIGNAL is set.
		
		Lparameters pnInteger
		
		Local lnOption As Integer
		
		This.CurlOptTimeOut = m.pnInteger
		
		m.lnOption = CURLOPT_TIMEOUT
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
	ENDPROC

	PROCEDURE curlopttransfertext_assign
		*!* CurlOptTransferText_Assign
		
		*!*	A parameter set to 1 tells the library to use ASCII mode for ftp transfers, 
		*!*	instead of the default binary transfer. For win32 systems it does not set 
		*!*	the stdout to binary mode. This option can be usable when transferring text 
		*!*	data between systems with different views on certain characters, such as 
		*!*	newlines or similar.
		
		*!*	libcurl does not do a complete ASCII conversion when doing ASCII transfers 
		*!*	over FTP. This is a known limitation/flaw that nobody has rectified. libcurl 
		*!*	simply sets the mode to ascii and performs a standard transfer. 
		*!*	Lparameters plValue
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptTransferText = m.plValue
		
		m.lnOption = CURLOPT_TRANSFERTEXT
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
	ENDPROC

	PROCEDURE curloptunrestrictedauth_assign
		*!* CurlOptUnrestrictedAuth_Assign
		
		*!*	A parameter set to 1 tells the library it can continue to send authentication 
		*!*	(user+password) when following locations, even when hostname changed. This 
		*!*	option is meaningful only when setting CURLOPT_FOLLOWLOCATION. 
		*!*	Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptUnrestrictedAuth = m.plValue
		
		m.lnOption = CURLOPT_UNRESTRICTED_AUTH 
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
	ENDPROC

	PROCEDURE curloptupload_assign
		*!* CurlOptUpload_Assign
		
		*!*	A parameter set to 1 tells the library to prepare for an upload. The 
		*!*	CURLOPT_READDATA and CURLOPT_INFILESIZE or CURLOPT_INFILESIZE_LARGE 
		*!*	options are also interesting for uploads. If the protocol is HTTP, 
		*!*	uploading means using the PUT request unless you tell libcurl otherwise.
		
		*!*	Using PUT with HTTP 1.1 implies the use of a "Expect: 100-continue" header. 
		*!*	You can disable this header with CURLOPT_HTTPHEADER as usual.
		
		*!*	If you use PUT to a HTTP 1.1 server, you can upload data without knowing the 
		*!*	size before starting the transfer if you use chunked encoding. You enable this 
		*!*	by adding a header like "Transfer-Encoding: chunked" with CURLOPT_HTTPHEADER. 
		*!*	With HTTP 1.0 or without chunked transfer, you must specify the size. 
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptUpload = m.plValue
		
		m.lnOption = CURLOPT_UPLOAD
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
	ENDPROC

	PROCEDURE curlopturl_assign
		*!*	CurlOptUrl_Assign
		
		*!*	The actual URL to deal with. The parameter should be a char * to a zero terminated string.
		
		*!*	If the given URL lacks the protocol part ("http://" or "ftp://" etc), it will attempt 
		*!*	to guess which protocol to use based on the given host name. If the given protocol of 
		*!*	the set URL is not supported, libcurl will return on error (CURLE_UNSUPPORTED_PROTOCOL) 
		*!*	when you call curl_easy_perform(3) or curl_multi_perform(3). Use curl_version_info(3) 
		*!*	for detailed info on which protocols that are supported.
		
		*!*	The string given to CURLOPT_URL must be url-encoded and following the RFC 2396 
		*!*	(http://curl.haxx.se/rfc/rfc2396.txt).
		
		*!*	CURLOPT_URL is the only option that must be set before curl_easy_perform(3) is called. 
		
		Lparameters pcString
		
		This.CurlOptUrl = m.pcString
		
		If Empty(m.pcString) Then
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_URL, 0)
		Else
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_URL, m.pcString)
		Endif
		
		
	ENDPROC

	PROCEDURE curloptuseragent_assign
		*!*	CurlOptUserAgent_Assign
		
		*!* IE6 USer-Agent: "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)"
		
		*!*	Pass a pointer to a zero terminated string as parameter. It will be used to set the
		*!*	User-Agent: header in the http request sent to the remote server. This can be used to
		*!*	fool servers or scripts. You can also set any custom header with CURLOPT_HTTPHEADER.
		
		Lparameters pcString
		
		This.CurlOptUserAgent = m.pcString
		
		If Empty(m.pcString) Then
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_USERAGENT, 0)
		Else
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_USERAGENT, m.pcString)
		Endif
		
		
		
	ENDPROC

	PROCEDURE curloptuserpwd_assign
		*!*	CurlOptUserPwd_Assign
		
		*!*	Pass a char * as parameter, which should be [user name]:[password] to use for
		*!*	the connection. Use CURLOPT_HTTPAUTH to decide authentication method.
		
		*!*	When using NTLM, you can set domain by prepending it to the user name and
		*!*	separating the domain and name with a forward (/) or backward slash (\).
		*!*	Like this: "domain/user:password" or "domain\user:password". Some HTTP servers
		*!*	(on Windows) support this style even for Basic authentication.
		
		*!*	When using HTTP and CURLOPT_FOLLOWLOCATION, libcurl might perform several requests
		*!*	to possibly different hosts. libcurl will only send this user and password information
		*!*	to hosts using the initial host name (unless CURLOPT_UNRESTRICTED_AUTH is set),
		*!*	so if libcurl follows locations to other hosts it will not send the user and password
		*!*	to those. This is enforced to prevent accidental information leakage.
		
		Lparameters pcString
		
		This.CurlOptUserPwd = m.pcString
		
		If Empty(m.pcString) Then
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_USERPWD, 0)
		Else
			apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_USERPWD, m.pcString)
		Endif
		
		
	ENDPROC

	PROCEDURE curloptusessl_assign		&& Sets the level of SSL for ftp.
		*!* CurlOptUseSsl_Assign
		
		*!*	CURLOPT_USE_SSL
		
		*!*	Pass a long using one of the values from below, to make libcurl use 
		*!*	your desired level of SSL for the ftp transfer. (Added in 7.11.0)
		
		*!*	(This option was known as CURLOPT_FTP_SSL up to 7.16.4, and the constants 
		*!*	were known as CURLFTPSSL_*)
		
		*!*	CURLUSESSL_NONE
		
		*!*	Don't attempt to use SSL.
		
		*!*	CURLUSESSL_TRY
		
		*!*	Try using SSL, proceed as normal otherwise.
		
		*!*	CURLUSESSL_CONTROL
		
		*!*	Require SSL for the control connection or fail with CURLE_USE_SSL_FAILED.
		
		*!*	CURLUSESSL_ALL
		
		*!*	Require SSL for all communication or fail with CURLE_USE_SSL_FAILED. 
		
		Lparameters pnInteger
		
		Local lnOption As Integer
		
		This.CurlOptUseSsl = m.pnInteger
		
		m.lnOption = CURLOPT_USE_SSL
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.pnInteger)
		
	ENDPROC

	PROCEDURE curloptverbose_assign
		*!* CurlOptVerbose_Assign
		
		*!*	Set the parameter to 1 to get the library to display a lot of verbose
		*!*	information about its operations. Very useful for libcurl and/or protocol
		*!*	debugging and understanding. The verbose information will be sent to
		*!*	stderr, or the stream set with CURLOPT_STDERR.
		
		*!*	You hardly ever want this set in production use, you will almost always
		*!*	want this when you debug/report problems. Another neat option for
		*!*	debugging is the CURLOPT_DEBUGFUNCTION.
		
		Lparameters plValue
		
		Local lnOption As Integer, lnParam As Integer
		
		If Vartype(m.plValue) = "N" Then
			m.plValue = Iif(m.plValue # 0, TRUE, FALSE)
		Endif
		
		This.CurlOptVerbose = m.plValue
		
		m.lnOption = CURLOPT_VERBOSE
		
		m.lnParam = Iif(m.plValue, 1, 0)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, m.lnOption, m.lnParam)
		
		This._SetupLogFile()
	ENDPROC

	PROCEDURE curlversion		&& Returns a human readable string with the version number of libcurl and some of its important components.
		*!* CurlVersion()
		
		*!* curl_version - returns the libcurl version string 
		
		*!* char *curl_version( )
		
		*!* Returns a human readable string with the version number of 
		*!* libcurl and some of its important components (like OpenSSL version). 
		
		Return apiCurlVersion()
	ENDPROC

	PROCEDURE Destroy
		*!* Destroy()
		
		This._ClearSlists()
		
		apiCurlEasyCleanup(This.CurlEasyHandle)
		
		apiCurlGlobalCleanup()
		
		This._DestroyCallBacks()
		
		If This._DebugFileHandle # 0 Then
			This._FileClose(This._DebugFileHandle)
			This._DebugFileHandle = 0
		Endif
		
	ENDPROC

	PROCEDURE downloadfile		&& Downloads a remote file to a local file.
		*!* DownloadFile(cRemoteFile, cLocalFile, nResumeFrom)
		
		*!* Downloads a remote file to a local file
		
		Lparameters pcRemoteFile As String, pcLocalFile As String, pnResumeFrom As Integer, pcRange as String
		
		Local ;
			lnLocalFileHandle As Integer, ;
			lnResult As Integer
		
		If Vartype(m.pcRemoteFile) + Vartype(m.pcLocalFile) # "CC" Then
			Return CURLE_BAD_FUNCTION_ARGUMENT
		Endif
		
		This._SaveSettings()
		
		This.CurlOptNoBody = FALSE
		
		If Vartype(m.pnResumeFrom) = "N" Then
			This.CurlOptResumeFrom = m.pnResumeFrom
		Else
			This.CurlOptResumeFrom = 0
		Endif
		
		If Vartype(m.pcRange) = "C" Then
			This.CurlOptRange = m.pcRange
		Else
			This.CurlOptRange = ""
		Endif
		
		This.CurlOptUpload = FALSE
		This.CurlOptUrl = m.pcRemoteFile
		
		*!*  open local file for write:
		m.lnLocalFileHandle = This._FileOpen(m.pcLocalFile, 2)
		
		If m.lnLocalFileHandle = -1 Then
			m.lnLocalFileHandle = This._FileCreate(m.pcLocalFile, 0)
		Endif
		
		If m.lnLocalFileHandle = -1 Then
		
			m.lnResult = CURLE_WRITE_ERROR
		
		Else
		
			Do Case
		
				Case This.CurlOptResumeFrom = -1
					*!* Resume from end of local file
					This.CurlOptResumeFrom = This._FileSeek(m.lnLocalFileHandle, 0, 2)
		
				Case This.CurlOptResumeFrom = 0
					*!* no resume
					Fchsize(m.lnLocalFileHandle, 0)
		
				Otherwise
					*!* Resume from certain value
					This._FileSeek(m.lnLocalFileHandle, This.CurlOptResumeFrom, 0)
		
			Endcase
		
			*!* Pass the fileahandle to the CurlWriteCallBack method
			apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_WRITEDATA, m.lnLocalFileHandle)
		
			*!* Pass the filehandle to the CurlSeekCallback method
			apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_SEEKDATA, m.lnLocalFileHandle)
		
			*!* Save start time:
			This._PerformStartTime = This._GetTickCount()
		
			*!* apiCurlMultiAddHandle(This.CurlMultiHandle, This.CurlEasyHandle)
		
			*!* Download remote file:
			m.lnResult = This.CurlEasyPerform()
		
			*!* Close local file:
			This._FileClose(m.lnLocalFileHandle)
		
			apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_WRITEDATA, 0)
			apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_SEEKDATA, 0)
		
		Endif
		
		This._RestoreSettings()
		
		Return m.lnResult
		
		
	ENDPROC

	PROCEDURE downloadstring		&& Downloads a remote file to a string.
		*!* DownloaString(cRemoteFile, nResumeFrom, cRange)
		
		*!* Downloads a remote file to a string
		
		Lparameters pcRemoteFile As String, pnResumeFrom As Integer, pcRange As String
		
		Local ;
			lcTempFolder As String, ;
			lcFileName As String, ;
			lnResult As Integer, ;
			lcBuffer As String, ;
			lnVfpMaxStringSize As Integer, ;
			lnFileHandle As Integer, ;
			lnFileSize As Integer
		
		If Vartype(m.pcRemoteFile) # "C" Then
			Return ""
		Endif
		
		*!* To simplify, we store the data in a temp file, then return the contents
		
		*!* Get temp folder
		m.lcTempFolder = Sys(2023)
		
		If Not Directory(m.lcTempFolder)
			Md (m.lcTempFolder)
		Endif
		
		m.lcFileName = Addbs(m.lcTempFolder) + Lower(Sys(2015)) + ".tmp"
		
		*!* This is the maximum size for a string in VFP
		m.lnVfpMaxStringSize = 16777184
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_MAXFILESIZE, m.lnVfpMaxStringSize)
		
		m.lnResult = This.DownloadFile(m.pcRemoteFile, m.lcFileName, m.pnResumeFrom)
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_MAXFILESIZE, 0)
		
		m.lnFileHandle = This._FileOpen(m.lcFileName)
		
		*!* Get temp file size
		m.lnFileSize = This._FileSize(m.lnFileHandle)
		
		If m.lnResult = 0 And m.lnFileSize > m.lnVfpMaxStringSize Then
			m.lnFileSize = m.lnVfpMaxStringSize
			This._PerformLastCode = CURLE_PARTIAL_FILE
		Endif
		
		*!* Set file pointer to beginning of file
		This._FileSeek(m.lnFileHandle, 0, 0)
		
		*!* read file contents
		m.lcBuffer = This._FileRead(m.lnFileHandle, m.lnFileSize)
		
		This._FileClose(m.lnFileHandle)
		
		Delete File(m.lcFileName)
		
		Return m.lcBuffer
		
	ENDPROC

	PROCEDURE filedownloadfile		&& Downloads a remote file to a local file usinf the FILE protocol.
		*!* FileDownloadFile(cRemoteFile, cLocalFile, nResumeFrom, cRange)
		
		*!* Downloads a remote file to a local file using the FILE protocol
		
		Lparameters pcRemoteFile As String, pcLocalFile As String, pnResumeFrom As Integer, pcRange As String
		
		If Upper(Left(m.pcRemoteFile, 7)) # "FILE://" Then
			m.pcRemoteFile = "file://" + m.pcRemoteFile
		Endif
		
		Return This.DownloadFile(m.pcRemoteFile, m.pcLocalFile, m.pnResumeFrom, m.pcRange)
		
	ENDPROC

	PROCEDURE filedownloadstring		&& Downloads a remote file to a string using the FILE protocol.
		*!* FtpDownloaString(cRemoteFile, nResumeFrom, cRange)
		
		*!* Downloads a remote file to a string
		
		Lparameters pcRemoteFile As String, pnResumeFrom As Integer, pcRange as String
		
		If Upper(Left(m.pcRemoteFile, 7)) # "FILE://" Then
			m.pcRemoteFile = "file://" + m.pcRemoteFile
		Endif
		
		Return This.DownloadString(m.pcRemoteFile, m.pnResumeFrom, m.pcRange)
		
	ENDPROC

	PROCEDURE fileuploadfile		&& Uploads a file using the FTP protocol.
		*!* FileUploadFile(cRemoteFile, cLocalFile, nResumeFrom)
		
		*!* nResumeFrom:
		*!* 0 no resume
		*!* -1 from end of of remote file
		*!* N from specified N position
		*!* -2 append
		
		*!* Uploads a file
		
		Lparameters pcRemoteFile As String, pcLocalFile As String
		
		If Upper(Left(m.pcRemoteFile, 7)) # "FILE://" Then
			m.pcRemoteFile = "file://" + m.pcRemoteFile
		Endif
		
		Return This.UploadFile(m.pcRemoteFile, m.pcLocalFile, 0)
		
	ENDPROC

	PROCEDURE fileuploadstring		&& Uploads a string using the ftp protocol.
		*!* FtpUploadString(cRemoteFile, cString, nResumeFrom)
		
		*!* nResumeFrom:
		*!* 0 no resume
		*!* -1 from end of of remote file
		*!* N from specified N position
		*!* -2 append
		
		*!* Uploads a string
		
		Lparameters pcRemoteFile As String, pcString As String
		
		If Upper(Left(m.pcRemoteFile, 7)) # "FILE://" Then
			m.pcRemoteFile = "file://" + m.pcRemoteFile
		Endif
		
		Return This.UploadString(m.pcRemoteFile, m.pcString, 0)
		
	ENDPROC

	PROCEDURE formatbytesize
		*!* FormatByteSize(nBytes)
		
		*!* Returns a string
		
		Lparameters pnSizeInBytes
		
		If Vartype(m.pnSizeInBytes) # "N" Then
			Return ""
		Endif
		
		Local ;
			m.lnSize As Integer, ;
			m.lcSize, ;
			m.lcUnit As String
		
		Do Case
			Case m.pnSizeInBytes < 999					&& Bytes
				m.lnSize = m.pnSizeInBytes
				m.lcUnit = " Bytes"
			Case m.pnSizeInBytes < 1024^1 * 999			&& KiloBytes
				m.lnSize = m.pnSizeInBytes / 1024^1
				m.lcUnit = " KB"
			Case m.pnSizeInBytes < 1024^2 * 999			&& MegaBytes
				m.lnSize = m.pnSizeInBytes / 1024^2
				m.lcUnit = " MB"
			Case m.pnSizeInBytes < 1024^3 * 999			&& GigaBytes
				m.lnSize = m.pnSizeInBytes / 1024^3
				m.lcUnit = " GB"
			Otherwise
				m.lnSize = m.pnSizeInBytes / 1024^4		&& TeraBytes
				m.lcUnit = " TB"
		Endcase
		
		Do Case
			Case m.lnSize > 1000
				m.lnSize = Round(m.lnSize , 1)
				m.lcSize = Transform(m.lnSize, "9999.9")
			Case m.lnSize > 100
				m.lnSize = Round(m.lnSize , 1)
				m.lcSize = Transform(m.lnSize, "999.9")
			Case m.lnSize > 10
				m.lnSize = Round(m.lnSize , 1)
				m.lcSize = Transform(m.lnSize, "99.9")
			Case m.lnSize = 0
				m.lnSize = Round(m.lnSize , 0)
				m.lcSize = Transform(m.lnSize, "9")
		
			Otherwise
				m.lnSize = Round(m.lnSize , 2)
				m.lcSize = Transform(m.lnSize, "99.99")
		Endcase
		
		Return m.lcSize + m.lcUnit
		
	ENDPROC

	PROCEDURE formattimeseconds
		*!* FormatTimeSeconds(nSeconds)
		
		*!* Returns a string
		
		Lparameters pnSeconds
		
		If Vartype(m.pnSeconds) # "N" Then
			Return ""
		Endif
		
		If m.pnSeconds = 0 Then
			Return "0 s"
		Endif
		
		Local ;
			lnHours, ;
			lnMinutes, ;
			lnSeconds, ;
			lcHours, ;
			lcMinutes, ;
			lcSeconds
		
		m.lnHours = Int(m.pnSeconds / 3600)
		m.lnMinutes = Int((m.pnSeconds % 3600) / 60)
		m.lnSeconds = Int(m.pnSeconds % 3600 % 60)
		
		If m.lnHours > 0 Then
			m.lcHours = Transform(m.lnHours) + " h "
		Else
			m.lcHours = ""
		Endif
		
		If m.lnMinutes > 0 Then
			m.lcMinutes = Transform(m.lnMinutes) + " m "
		Else
			m.lcMinutes = ""
		Endif
		
		If m.lnSeconds > 0 Then
			m.lcSeconds = Transform(m.lnSeconds) + " s"
		Else
			m.lcSeconds = ""
		Endif
		
		Return m.lcHours + m.lcMinutes + m.lcSeconds
		
	ENDPROC

	PROCEDURE ftpappendfile		&& Represents the FTP protocol APPE method that is used to append a file to an existing file on an FTP server.
		*!* FtpAppendFile(cRemoteFile, cLocalFile)
		
		*!* Appends a file to an FTP server
		
		Lparameters pcRemoteFile As String, pcLocalFile As String
		
		Return This.UploadFile(m.pcRemoteFile, m.pcLocalFile, -2)
		
	ENDPROC

	PROCEDURE ftpappendstring		&& Represents the FTP protocol APPE method that is used to append a string to an existing file on an FTP server.
		*!* FtpAppendString(cRemoteFile, cString)
		
		*!* Appends a string to an FTP server file
		
		Lparameters pcRemoteFile As String, pcString As String
		
		Return This.UploadString(m.pcRemoteFile, m.pcString, -2)
		
	ENDPROC

	PROCEDURE ftpdeletefile		&& Represents the FTP protocol DELE method that is used to delete a file on an FTP server.
		*!* FtpDeleteFile(cRemoteFile)
		
		Lparameters pcRemoteFile As String
		
		Local ;
			lnResult As Integer
		
		If Vartype(m.pcRemoteFile ) # "C" Then
			Return CURLE_BAD_FUNCTION_ARGUMENT
		Endif
		
		*!* If no file name in URL:
		If m.pcRemoteFile == Justpath(m.pcRemoteFile) Then
			Return CURLE_BAD_FUNCTION_ARGUMENT
		Endif
		
		This._SaveSettings()
		
		This.CurlOptUrl = Justpath(m.pcRemoteFile) + "/"
		This.CurlOptNoBody = TRUE
		This.CurlOptUpload = FALSE
		This.CurlOptFileTime = FALSE
		This.CurlOptPostQuote = "DELE " + Justfname(m.pcRemoteFile)
		
		m.lnResult = This.CurlEasyPerform()
		
		This._RestoreSettings()
		
		Return m.lnResult
		
	ENDPROC

	PROCEDURE ftpdownloadfile		&& Downloads a remote file to a local file using the FTP protocol.
		*!* FtpDownloadFile(cRemoteFile, cLocalFile, nResumeFrom, cRange)
		
		*!* Downloads a remote file to a local file
		
		Lparameters pcRemoteFile As String, pcLocalFile As String, pnResumeFrom As Integer, pcRange as String
		
		Return This.DownloadFile(m.pcRemoteFile, m.pcLocalFile, m.pnResumeFrom, m.pcRange)
		
	ENDPROC

	PROCEDURE ftpdownloadstring		&& Downloads a remote file to a string using the FTP protocol.
		*!* FtpDownloaString(cRemoteFile, nResumeFrom, cRange)
		
		*!* Downloads a remote file to a string
		
		Lparameters pcRemoteFile As String, pnResumeFrom As Integer, pcRange as String
		
		Return This.DownloadString(m.pcRemoteFile, m.pnResumeFrom, m.pcRange)
		
	ENDPROC

	PROCEDURE ftpgetdatetimestamp		&& Retrieves the date-time stamp of a remote file using the FTP protocol.
		*!* FtpGetDateTimeStamp(cRemoteFile, lReuse)
		
		*!* lReuse is a parameter for internal use by the class, employed when
		*!* calling GetFileSize and GetDateTimeStamp one after the other.
		*!* setting lReuse to TRUE saves us from contacting the FTP server again
		*!* since we already have the data from the previous call.
		
		Lparameters pcRemoteFile As String, plReuse As Boolean
		
		Return This.GetDateTimeStamp(m.pcRemoteFile, m.plReuse)
		
	ENDPROC

	PROCEDURE ftpgetfeatures		&& Represents the FTP protocol FEAT method that is used to retrieve the features of an FTP server.
		*!* FtpGetFeatures
		
		Lparameters pcUrl As String
		
		Local ;
			lnResult As Integer
		
		If Vartype(m.pcUrl) # "C" Then
			Return ""
		Endif
		
		This._SaveSettings()
		
		This.CurlOptUrl = m.pcUrl
		This.CurlOptNoBody = TRUE
		This.CurlOptUpload = FALSE
		This.CurlOptPostQuote = "FEAT"
		
		This._FtpGetFeaturesStatus = 1
		This._FtpGetFeaturesData = ""
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_HEADERFUNCTION, This._HeaderCallBackPtr)
		
		m.lnResult = This.CurlEasyPerform()
		
		apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_HEADERFUNCTION, 0)
		
		This._FtpGetFeaturesStatus = 0
		
		This._RestoreSettings()
		
		If m.lnResult = 0 Or This.CurlInfoResponseCode() = 211 Then
			Return This._FtpGetFeaturesData
		Else
			Return ""
		Endif
		
		
	ENDPROC

	PROCEDURE ftpgetfilesize		&& Retrieves the size of a remote file using the FTP protocol.
		*!* FtpGetFileSize(cRemoteFile, lReuse)
		
		*!* lReuse is a parameter for internal use by the class, employed when
		*!* calling GetFileSize and GetDateTimeStamp one after the other.
		*!* setting lReuse to TRUE saves us from contacting the FTP server again
		*!* since we already have the data from the previous call.
		
		Lparameters pcRemoteFile As String, plReuse As Boolean
		
		Return This.GetFileSize(m.pcRemoteFile, m.plReuse)
		
	ENDPROC

	PROCEDURE ftplist		&& Fills the Ftpfiles array with information about an FTP directory.
		*!* FtpList(cUrl)
		
		*!* The Url must be a directory, not a file
		*!* returns the number of files and directories found
		*!* Fills the FtpFiles array property
		*!* and the FtpFileCount property
		
		*!* If the FTP server supports MLSD, we call FtpListDirectoryDetails
		*!* using the MLSD command and parse the result
		*!* otherwise, we call FtpListDirectoryDetails and
		*!* FtpListDirectory and then call GetDateTimeStamp and
		*!* GetFileSize for each file
		
		Lparameters pcUrl As String
		
		Local ;
			lcFeatures As String
		
		If Vartype(m.pcUrl) # "C" Then
			This.FtpFileCount = 0
			Return -1
		Endif
		
		*!*	Updates FtpFiles array with the following data
		*!* Stores number of files/folders to FtpFileCount
		
		*!*	1 File name Character
		*!*	2 File size Numeric
		*!*	3 DateTime last modified DateTime
		*!*	4 File attributes Character "A" for file or "D" for directory
		
		*!*	IF FtpFileCount is 0, FtpFiles may contain info from previous FtpList()
		
		*!* Add forward slash:
		If Right(m.pcUrl, 1) # "/" Then
			m.pcUrl = m.pcUrl + "/"
		Endif
		
		m.lcFeatures = This.FtpGetFeatures(m.pcUrl)
		
		Do Case
			Case "MLSD" $ m.lcFeatures
				This._FtpListMlsd(m.pcUrl)
		
			Case "MLST" $ m.lcFeatures
				This._FtpListPlain(m.pcUrl)
		
			Otherwise
				This._FtpListPlain(m.pcUrl)
		Endcase
		
		Return This.FtpFileCount
		
		
	ENDPROC

	PROCEDURE ftplistdirectory		&& Represents the FTP protocol NLIST method that gets a short listing of the files on an FTP server.
		*!* FtpListDirectory(cUrl)
		
		*!* The Url must be a directory, not a file
		*!* returns a string with one line for each file and directory name
		
		Lparameters pcUrl As String
		
		If Vartype(m.pcUrl) # "C" Then
			Return ""
		Endif
		
		If Right(m.pcUrl, 1) # "/" Then
			m.pcUrl = m.pcUrl + "/"
		Endif
		
		*!* Save current values:
		This._SaveSettings()
		
		This.CurlOptUrl = m.pcUrl
		This.CurlOptDirListOnly = TRUE
		This.CurlOptUpload = FALSE
		This.CurlOptNoBody = FALSE
		
		This._DataBuffer = ""
		
		This.CurlEasyPerform()
		
		*!* Restore values:
		This._RestoreSettings()
		
		Return This._DataBuffer
		
		
	ENDPROC

	PROCEDURE ftplistdirectorydetails		&& Represents the FTP protocol LIST method that gets a detailed listing of the files on an FTP server.
		*!* FtpListDirectoryDetails(cUrl, lUseMlsd)
		
		*!* The Url must be a directory, not a file
		*!* returns a string with one line for each file and directory details
		*!* as returned by the FTP server, no parsing
		
		*!* lUseMlsd is an internal parameter used by the class, to use MLSD
		*!* instead of LIST to get the information
		
		Lparameters pcUrl As String, plUseMlsd As Boolean
		
		If Vartype(m.pcUrl) # "C" Then
			Return ""
		Endif
		
		*!* Save current values:
		This._SaveSettings
		
		*!*	If Right(m.pcUrl, 1) # "/" Then
		*!*		m.pcUrl = m.pcUrl + "/"
		*!*	Endif
		
		This.CurlOptUrl = m.pcUrl
		This.CurlOptDirListOnly = FALSE
		This.CurlOptUpload = FALSE
		This.CurlOptNoBody = FALSE
		
		If m.plUseMlsd = TRUE Then
			This.CurlOptCustomRequest = "MLSD"
		Endif
		
		This._DataBuffer = ""
		
		This.CurlEasyPerform()
		
		*!* Restore values:
		This._RestoreSettings()
		
		Return This._DataBuffer
		
		
	ENDPROC

	PROCEDURE ftpmakedirectory		&& Represents the FTP protocol MKD method that creates a directory on an FTP server.
		*!* FtpMakeDirectory(cRemoteDir)
		
		Lparameters pcRemoteDir As String
		
		If Vartype(m.pcRemoteDir) # "C" Then
			Return ""
		Endif
		
		*!* Add forward slash:
		If Right(m.pcRemoteDir, 1) # "/" Then
			m.pcRemoteDir = m.pcRemoteDir + "/"
		Endif
		
		This._SaveSettings()
		
		This.CurlOptFtpCreateMissingDirs = TRUE
		This.CurlOptNoBody = TRUE
		This.CurlOptUrl = m.pcRemoteDir
		
		m.lnResult = This.CurlEasyPerform()
		
		This._RestoreSettings()
		
		Return m.lnResult
		
	ENDPROC

	PROCEDURE ftpnoop		&& Represents the FTP protocol  NOOP command.
		*!* FtpCommandNoop()
		
		Lparameters pcUrl As String
		
		Local ;
			lnResult As Integer
		
		If Vartype(m.pcUrl) # "C" Then
			Return CURLE_BAD_FUNCTION_ARGUMENT
		Endif
		
		*!* Save some properties:
		This._SaveSettings()
		
		This.CurlOptUrl = m.pcUrl
		This.CurlOptNoBody = TRUE
		This.CurlOptUpload = FALSE
		This.CurlOptPostQuote = "NOOP"
		
		m.lnResult = This.CurlEasyPerform()
		
		This._RestoreSettings()
		
		Return m.lnResult
		
	ENDPROC

	PROCEDURE ftpremovedirectory		&& Represents the FTP protocol RMD method that removes a directory.
		*!* FtpRemoveDirectory(cRemoteDir)
		
		Lparameters pcRemoteDir As String
		
		Local ;
			lcPath As String, ;
			lcDirectory As String, ;
			lnResult As Integer
		
		If Vartype(m.pcRemoteDir) # "C" Then
			Return ""
		Endif
		
		*!* To delete a folder, we have to be in the parent folder
		*!* so lets get the path to our folder and the name of it.
		
		m.lcPath = m.pcRemoteDir
		
		*!* Remove trailing forward slash
		If Right(m.lcPath , 1) = "/" Then
			m.lcPath = Left(m.lcPath , Len(m.lcPath) - 1)
		Endif
		
		m.lcDirectory = Justfname(m.lcPath)
		m.lcPath = Justpath(m.lcPath)
		
		*!* Add trailing forward slash:
		If Right(m.lcPath, 1) # "/" Then
			m.lcPath = m.lcPath + "/"
		Endif
		
		This._SaveSettings()
		
		This.CurlOptFtpCreateMissingDirs = FALSE
		This.CurlOptNoBody = TRUE
		This.CurlOptUrl = m.lcPath 
		This.CurlOptPostQuote = "RMD " + m.lcDirectory
		
		m.lnResult = This.CurlEasyPerform()
		
		This._RestoreSettings()
		
		Return m.lnResult
		
	ENDPROC

	PROCEDURE ftprename		&& Represents the FTP protocol RNFR and RNTO methods that renames a file.
		*!* FtpRename(cOldName, cNewname)
		
		Lparameters pcOldName As String, pcNewname As String
		
		Local ;
			lnResult As Integer
		
		If Vartype(m.pcOldName) + Vartype(m.pcNewname) # "CC" Then
			Return CURLE_BAD_FUNCTION_ARGUMENT
		Endif
		
		*!* If no old file name:
		If m.pcOldName == Justpath(m.pcOldName) Then
			Return CURLE_BAD_FUNCTION_ARGUMENT
		Endif
		
		*!* If no new file name
		If m.pcNewname == Justpath(m.pcNewname) Then
			Return CURLE_BAD_FUNCTION_ARGUMENT
		Endif
		
		*!* if paths not equal
		If Justpath(m.pcOldName) # Justpath(m.pcNewname) Then
			Return CURLE_BAD_FUNCTION_ARGUMENT
		Endif
		
		This._SaveSettings()
		
		This.CurlOptUrl = Justpath(m.pcOldName) + "/"
		This.CurlOptNoBody = TRUE
		This.CurlOptUpload = FALSE
		This.CurlOptFileTime = FALSE
		This.CurlOptPostQuote = "RNFR " + Justfname(m.pcOldName) + "|" + "RNTO " + Justfname(m.pcNewname)
		
		m.lnResult = This.CurlEasyPerform()
		
		This._RestoreSettings()
		
		Return m.lnResult
		
	ENDPROC

	PROCEDURE ftpuploadfile		&& Uploads a file using the FTP protocol.
		*!* FtpUploadFile(cRemoteFile, cLocalFile, nResumeFrom)
		
		*!* nResumeFrom:
		*!* 0 no resume
		*!* -1 from end of of remote file
		*!* N from specified N position
		*!* -2 append
		
		*!* Uploads a file
		
		Lparameters pcRemoteFile As String, pcLocalFile As String, pnResumeFrom As Integer
		
		Return This.UploadFile(m.pcRemoteFile, m.pcLocalFile, m.pnResumeFrom)
		
	ENDPROC

	PROCEDURE ftpuploadstring		&& Uploads a string using the ftp protocol.
		*!* FtpUploadString(cRemoteFile, cString, nResumeFrom)
		
		*!* nResumeFrom:
		*!* 0 no resume
		*!* -1 from end of of remote file
		*!* N from specified N position
		*!* -2 append
		
		*!* Uploads a string
		
		Lparameters pcRemoteFile As String, pcString As String, pnResumeFrom As Integer
		
		Return This.UploadString(m.pcRemoteFile, m.pcString, m.pnResumeFrom)
		
	ENDPROC

	PROCEDURE getdatetimestamp		&& Retrieves the date-time stamp of a remote file.
		*!* GetDateTimeStamp(cRemoteFile, lReuse)
		
		*!* lReuse is a parameter for internal use by the class, employed when
		*!* calling GetFileSize and GetDateTimeStamp one after the other.
		*!* setting lReuse to TRUE saves us from contacting the FTP server again
		*!* since we already have the data from the previous call.
		
		Lparameters pcRemoteFile As String, plReuse As Boolean
		
		Local ;
			lnFileTime As Integer, ;
			ltFileTime As Datetime, ;
			lnResult As Integer
		
		If Vartype(m.pcRemoteFile) # "C" Then
			Return {// ::}
		Endif
		
		If m.plReuse = FALSE Then
			*!* Save some properties:
			This._SaveSettings()
		
			This.CurlOptUrl = m.pcRemoteFile
			This.CurlOptNoBody = TRUE
			This.CurlOptUpload = FALSE
			This.CurlOptFileTime = TRUE
		
			m.lnResult = This.CurlEasyPerform()
		Else
			m.lnResult = CURLE_OK
		Endif
		
		m.lnFileTime = -1
		
		If m.lnResult = CURLE_OK
			apiCurlEasyGetInfoInteger(This.CurlEasyHandle, CURLINFO_FILETIME, @m.lnFileTime)
		Endif
		
		*!* m.lnFileTime = number of seconds since 1 jan 1970 in the GMT/UTC time zone
		
		If m.lnFileTime = -1 Then
			m.ltFileTime = {// ::}
		Else
			m.ltFileTime = Datetime(1970, 01, 01, 0, 0, 0) + m.lnFileTime
		Endif
		
		If m.plReuse = FALSE Then
			*!* Restore some properties:
			This._RestoreSettings()
		Endif
		
		Return m.ltFileTime
		
	ENDPROC

	PROCEDURE getfilesize		&& Retrieves the size of a remote file.
		*!* GetFileSize(cRemoteFile, lReuse)
		
		*!* lReuse is a parameter for internal use by the class, employed when
		*!* calling GetFileSize and GetDateTimeStamp one after the other.
		*!* setting lReuse to TRUE saves us from contacting the FTP server again
		*!* since we already have the data from the previous call.
		
		Lparameters pcRemoteFile As String, plReuse as Boolean
		
		Local ;
			lnFileSize As Integer, ;
			lnResult As Integer
		
		If Vartype(m.pcRemoteFile) # "C" Then
			Return -1
		Endif
		
		If m.plReuse = FALSE Then
			*!* Save some properties:
			This._SaveSettings()
		
			This.CurlOptUrl = m.pcRemoteFile
			This.CurlOptNoBody = TRUE
			This.CurlOptUpload = FALSE
		
			*!* Get the file time also, we set this so if the file if not found,
			*!* we get an error back from curleasyperform
			This.CurlOptFileTime = TRUE
		
			m.lnResult = This.CurlEasyPerform()
		Else
			m.lnResult = CURLE_OK
		Endif
		
		m.lnFileSize = -1
		
		If m.lnResult = CURLE_OK Then
			apiCurlEasyGetInfoDouble(This.CurlEasyHandle, CURLINFO_CONTENT_LENGTH_DOWNLOAD , @m.lnFileSize)
		Endif
		
		If m.plReuse = FALSE Then
			This._RestoreSettings()
		Endif
		
		Return m.lnFileSize
		
	ENDPROC

	PROCEDURE httpdownloadfile		&& Downloads a remote file to a local file using the HTTP protocol.
		*!* HttpDownloadFile(cRemoteFile, cLocalFile, nResumeFrom, cRange)
		
		*!* Downloads a remote file to a local file
		
		Lparameters pcRemoteFile As String, pcLocalFile As String, pnResumeFrom As Integer, pcRange as String
		
		Return This.DownloadFile(m.pcRemoteFile, m.pcLocalFile, m.pnResumeFrom, m.pcRange)
		
	ENDPROC

	PROCEDURE httpdownloadstring		&& Downloads a remote file to a string using the HTPP protocol.
		*!* HttpDownloaString(cRemoteFile, nResumeFrom, cRange)
		
		*!* Downloads a remote file to a string
		
		Lparameters pcRemoteFile As String, pnResumeFrom As Integer, pcRange as String
		
		Return This.DownloadString(m.pcRemoteFile, m.pnResumeFrom, m.pcRange)
	ENDPROC

	PROCEDURE httpgetdatetimestamp		&& Retrieves the date-time stamp of a remote file using the HTPP protocol.
		*!* HttpGetDateTimeStamp(cRemoteFile, lReuse)
		
		*!* lReuse is a parameter for internal use by the class, employed when
		*!* calling GetFileSize and GetDateTimeStamp one after the other.
		*!* setting lReuse to TRUE saves us from contacting the FTP server again
		*!* since we already have the data from the previous call.
		
		Lparameters pcRemoteFile As String, plReuse As Boolean
		
		Return This.GetDateTimeStamp(m.pcRemoteFile, m.plReuse)
	ENDPROC

	PROCEDURE httpgetfilesize		&& Retrieves the size of a remote file using the HTPP protocol.
		*!* HttpGetFileSize(cRemoteFile, lReuse)
		
		*!* lReuse is a parameter for internal use by the class, employed when
		*!* calling GetFileSize and GetDateTimeStamp one after the other.
		*!* setting lReuse to TRUE saves us from contacting the FTP server again
		*!* since we already have the data from the previous call.
		
		Lparameters pcRemoteFile As String, plReuse As Boolean
		
		Return This.GetFileSize(m.pcRemoteFile, m.plReuse)
		
	ENDPROC

	PROCEDURE httppostfile		&& Performs an HTTP POST of the specified file.
		*!* HttpPostString(cUrl, cLocalFile)
		
		Lparameters pcUrl As String, pcLocalFile As String
		
		Local ;
			lcString As String
		
		If Vartype(m.pcUrl) + Vartype(m.pcLocalFile) # "CC" Then
			Return CURLE_BAD_FUNCTION_ARGUMENT
		Endif
		
		If Not File(m.pcLocalFile) Then
			Return CURLE_READ_ERROR
		Endif
		
		m.lcString = Filetostr(m.pcLocalFile)
		
		Return This.HttpPostString(m.pcUrl, m.lcString)
		
	ENDPROC

	PROCEDURE httppoststring		&& Performs an HTTP POST of the specified string.
		*!* HttpPostString(cUrl, cString)
		
		Lparameters pcUrl As String, pcString As String
		
		Local ;
			lnPostSize As Integer, ;
			lnResult As Integer
		
		If Vartype(m.pcUrl) + Vartype(m.pcString) # "CC" Then
			Return CURLE_BAD_FUNCTION_ARGUMENT
		Endif
		
		This._SaveSettings()
		
		This.CurlOptPost = TRUE
		This.CurlOptNoBody = FALSE
		This.CurlOptUpload = FALSE
		This.CurlOptUrl = m.pcUrl
		
		m.lnPostSize = Len(m.pcString)
		
		This.CurlOptPostFieldSize =  m.lnPostSize
		
		This.CurlOptCopyPostFields = m.pcString
		
		m.lnResult = This.CurlEasyPerform()
		
		This._RestoreSettings()
		
		This.CurlOptPostFieldSize = 0
		
		This.CurlOptCopyPostFields = ""
		
		Return m.lnResult
		
	ENDPROC

	PROCEDURE httpuploadfile		&& Uploads a file using the HTPP protocol.
		*!* HttpUploadFile(cRemoteFile, cLocalFile, nResumeFrom)
		
		*!* nResumeFrom:
		*!* 0 no resume
		
		*!* Uploads a file
		
		Lparameters pcRemoteFile As String, pcLocalFile As String, pnResumeFrom As Integer
		
		Return This.UploadFile(m.pcRemoteFile, m.pcLocalFile, 0)
		
	ENDPROC

	PROCEDURE httpuploadstring		&& Uploads a string using the HTPP protocol.
		*!* HttpUploadString(cRemoteFile, cString, nResumeFrom)
		
		*!* nResumeFrom:
		*!* 0 no resume
		
		*!* Uploads a string
		
		Lparameters pcRemoteFile As String, pcString As String, pnResumeFrom As Integer
		
		Return This.UploadString(m.pcRemoteFile, m.pcString, 0)
		
	ENDPROC

	PROCEDURE Init
		*!* Init()
		
		External Procedure libcurl.prg
		Do (Addbs(Justpath(This.ClassLibrary)) + "libcurl.prg")
		
		*!* Initialize cUrl dll
		apiCurlGlobalInit(CURL_GLOBAL_DEFAULT)
		
		*!* Create callbacks
		This._CreateCallBacks()
		
		*!* Get an easy handle
		This.CurlEasyHandle = apiCurlEasyInit()
		
		*!* Apply essential properties
		This._SetDefaultProperties()
		
		If Empty(This.LogFileName) Then
			This.LogFileName = Addbs(Justpath(This.ClassLibrary)) + "libcurl.log"
		Endif
		
	ENDPROC

	PROCEDURE logfilereset		&& Resets the log file
		*!* LogFileReset()
		
		If Not File(This.LogFileName) Then
			Return
		Endif
		
		If This.CurlOptVerbose = TRUE Then
			This.CurlOptVerbose = FALSE
			Delete File (This.LogFileName)
			This.CurlOptVerbose = TRUE
		Else
			Delete File (This.LogFileName)
		Endif
		
		Return TRUE
		
	ENDPROC

	PROCEDURE transferprogress		&& Event. Fires about every second. when a transfer is in progress.
		*!* TransferProgress
		
		*!* Use this event to show the progress of the operation.
		
		Lparameters pnBytesTotal, pnBytesDone, pnBytesLeft, pnSpeed, pnTimeTotal, pnTimeDone, pnTimeLeft
		
	ENDPROC

	PROCEDURE uploadfile		&& Uploads a file.
		*!* UploadFile(cRemoteFile, cLocalFile, nResumeFrom)
		
		*!* nResumeFrom:
		*!* 0 no resume
		*!* -1 from end of of remote file
		*!* N from specified N position
		*!* -2 append
		
		*!* Uploads a file
		
		Lparameters pcRemoteFile As String, pcLocalFile As String, pnResumeFrom As Integer
		
		Local ;
			lnLocalFileHandle As Integer, ;
			lnFileSize As Integer, ;
			lnResult As Integer, ;
			lnFileSizeLo As Integer, ;
			lnFileSizeHi As Integer
		
		If Vartype(m.pcRemoteFile) + Vartype(m.pcLocalFile) # "CC" Then
			Return CURLE_BAD_FUNCTION_ARGUMENT
		Endif
		
		This._SaveSettings()
		
		This.CurlOptNoBody = FALSE
		This.CurlOptUpload = TRUE
		This.CurlOptUrl = m.pcRemoteFile
		
		Do Case
		
			Case Vartype(m.pnResumeFrom) # "N"
				*!* No resume
				This.CurlOptResumeFrom = 0
		
			Case m.pnResumeFrom = -2
				*!* Append
				This.CurlOptResumeFrom = 0
				This.CurlOptAppend = TRUE
		
			Otherwise
				This.CurlOptResumeFrom = m.pnResumeFrom
		
		Endcase
		
		*!*  open local file for read:
		m.lnLocalFileHandle  = This._FileOpen(m.pcLocalFile, 0)
		
		If m.lnLocalFileHandle = -1 Then
		
			m.lnResult = CURLE_READ_ERROR
		
		Else
		
			*!* Get local File size:
			m.lnFileSize = This._FileSize(m.lnLocalFileHandle)
		
			*!* go to begining of file, _SeekCallBack will move the file pointer
			*!* if CurlOptResumeFrom is # 0
			This._FileSeek(m.lnLocalFileHandle, 0, 0)
		
			*!* Pass the fileahandle to the CurlReadCallBack method
			apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_READDATA, m.lnLocalFileHandle)
		
			*!* Get the file size
			m.lnFileSize = This._FileSize(m.lnLocalFileHandle)
		
			*!* Split into Int64 Low and High parts:
			m.lnFileSizeLo = m.lnFileSize % 2^32
			m.lnFileSizeHi = Int((m.lnFileSize - m.lnFileSizeLo) / 2^32)
		
			If m.lnFileSizeLo < 0 Then
				m.lnFileSizeLo = m.lnFileSizeLo + 2^32
			Endif
		
			*!* Pass file size to libcurl:
			apiCurlEasySetOptInt64(This.CurlEasyHandle, CURLOPT_INFILESIZE_LARGE, m.lnFileSizeLo, m.lnFileSizeHi)
		
			*!* Pass the filehandle to the CurlSeekCallback method
			apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_SEEKDATA, m.lnLocalFileHandle)
		
			*!* Save start time:
			This._PerformStartTime = This._GetTickCount()
		
			*!* Upload local file:
			m.lnResult = This.CurlEasyPerform()
		
			*!* Close local file:
			This._FileClose(m.lnLocalFileHandle)
		
			apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_READDATA, 0)
			apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_INFILESIZE, 0)
			apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_SEEKDATA, 0)
		
		Endif
		
		This._RestoreSettings()
		
		Return m.lnResult
		
	ENDPROC

	PROCEDURE uploadstring		&& Uploads a string.
		*!* UploadString(cRemoteFile, cString, nResumeFrom)
		
		*!* nResumeFrom:
		*!* 0 no resume
		*!* -1 from end of of remote file
		*!* N from specified N position
		*!* -2 append
		
		*!* Uploads a string
		
		Lparameters pcRemoteFile As String, pcString As String, pnResumeFrom As Integer
		
		Local ;
			lcTempFolder As String, ;
			lcFileName As String, ;
			lnResult As Integer
		
		If Vartype(m.pcRemoteFile) + Vartype(m.pcString) # "CC" Then
			Return CURLE_BAD_FUNCTION_ARGUMENT
		Endif
		
		*!* To simplify, we will just store the string to a temp file, then use UploadFile
		
		*!* Get temp folder
		m.lcTempFolder = Sys(2023)
		
		If Not Directory(m.lcTempFolder)
			Md (m.lcTempFolder)
		Endif
		
		m.lcFileName = Addbs(m.lcTempFolder) + Lower(Sys(2015)) + ".tmp"
		
		Strtofile(m.pcString, m.lcFileName, 0)
		
		m.lnResult = This.UploadFile(m.pcRemoteFile, m.lcFileName, m.pnResumeFrom)
		
		Delete File(m.lcFileName)
		
		Return m.lnResult
		
	ENDPROC

	PROCEDURE _clearslists
		*!* _ClearSlists()
		
		*!* Release memory of slists if any:
		
		If This._PostQuoteSlist # 0 Then
			apiCurlSlistFreeAll(This._PostQuoteSlist)
			This._PostQuoteSlist = 0
		Endif
		
		If This._PreQuoteSlist # 0 Then
			apiCurlSlistFreeAll(This._PreQuoteSlist)
			This._PreQuoteSlist = 0
		Endif
		
		If This._QuoteSlist # 0 Then
			apiCurlSlistFreeAll(This._QuoteSlist)
			This._QuoteSlist = 0
		Endif
		
		If This._HeaderSlist # 0 Then
			apiCurlSlistFreeAll(This._HeaderSlist)
			This._HeaderSlist = 0
		Endif
		
	ENDPROC

	PROCEDURE _createcallbacks
		*!* _CreateCallBacks()
		
		*!*	vfp2c32.fll version 2.0.0.4
		*!*	CreateCallbackFunc now also handles these additional datatypes:
		*!*	- "INT64" -> signed 64bit integer
		*!*	- "UINT64" -> unsigned 64bit integer
		
		*!*	3. CreateCallbackFunc now also supports callback functions with the "cdecl" 
		*!*	calling convention (the last version always created functions with the windows 
		*!*	standard "stdcall" calling convention) - libcurl uses the "cdecl" calling convetion 
		*!*	- that's why you probably got the dll exceptions. To create a cdecl callback func 
		*!*	pass "8" as the last parameter to the CreateCallbackFunc function.
		
		********************************************************************************
		*!*	typedef int (*curl_debug_callback)
		*!*	       (CURL *handle,      /* the handle/transfer this concerns */
		*!*	        curl_infotype type, /* what kind of data */
		*!*	        char *data,        /* points to the data */
		*!*	        size_t size,       /* size of the data pointed to */
		*!*	        void *userptr);    /* whatever the user please */
		
		This._DebugCallBackPtr = ;
		CreateCallBackFunc("_DebugCallback","INTEGER","INTEGER,INTEGER,INTEGER,INTEGER,INTEGER", This, 1)
		
		********************************************************************************
		*!*	typedef int (*curl_progress_callback)(void *clientp,
		*!*	                                      double dltotal,
		*!*	                                      double dlnow,
		*!*	                                      double ultotal,
		*!*	                                      double ulnow)
		
		This._ProgressCallBackPtr = ;
		CreateCallBackFunc("_ProgressCallBack","INTEGER", "INTEGER,DOUBLE,DOUBLE,DOUBLE,DOUBLE", This, 8)
		
		********************************************************************************
		*!*	typedef size_t (*curl_read_callback)(char *buffer,
		*!*	                                      size_t size,
		*!*	                                      size_t nitems,
		*!*	                                      void *instream)
		
		This._ReadCallBackPtr = ;
		CreateCallBackFunc("_ReadCallBack", "INTEGER","INTEGER,INTEGER,INTEGER,INTEGER", This, 1)
		
		********************************************************************************
		*!*	typedef int (*curl_seek_callback)(void *instream,
		*!*	                                  curl_off_t offset,
		*!*	                                  int origin); /* 'whence' */
		
		This._SeekCallBackPtr  = ;
		CreateCallBackFunc("_SeekCallBack", "INTEGER","INTEGER,INT64,INTEGER", This, 8)
		
		********************************************************************************
		*!*	typedef size_t (*curl_write_callback)(char *buffer,
		*!*	                                      size_t size,
		*!*	                                      size_t nitems,
		*!*	                                      void *outstream)
		
		This._WriteCallBackPtr = ;
		CreateCallBackFunc("_WriteCallBack","INTEGER", "INTEGER,INTEGER,INTEGER,INTEGER", This, 1)
		
		********************************************************************************
		*!*	size_t function( void *ptr, size_t size, size_t nmemb, void *stream)
		
		This._HeaderCallBackPtr = ;
		CreateCallBackFunc("_HeaderCallBack","INTEGER", "INTEGER,INTEGER,INTEGER,INTEGER", This, 1)
		
		
	ENDPROC

	PROCEDURE _debugcallback		&& Replaces the standard debug function used when CurlOptVerbose is in effect. This method receives debug information.
		*!* _DebugCallBack
		
		Lparameters pnEasyHandle, pnInfoType, pnBufferAddress, pnSize, pnLocalFileHandle
		
		If m.pnLocalFileHandle = 0 Then
			Return 0
		Endif
		
		Local lcBytes As String
		
		m.lcBytes = Chrtran(Sys(2600, pnBufferAddress, m.pnSize), CRLF, "|")
		
		If Right(m.lcBytes, 1) = "|" Then
			m.lcBytes = Left(m.lcBytes, Len(m.lcBytes) - 1)
		Endif
		
		Do Case
			Case m.pnInfoType = CURLINFO_HEADER_OUT And Left(m.lcBytes, 4) == "PASS"	&& Mask the password
				m.lcBytes = "2 PASS ********" + CRLF
		
			Case m.pnInfoType = CURLINFO_DATA_IN
				m.lcBytes = "3 CURLINFO_DATA_IN" + CRLF
		
			Case m.pnInfoType = CURLINFO_DATA_OUT
				m.lcBytes = "4 CURLINFO_DATA_OUT" + CRLF
		
			Case m.pnInfoType = CURLINFO_SSL_DATA_IN
				m.lcBytes = "5 CURLINFO_SSL_DATA_IN" + CRLF
		
			Case m.pnInfoType = CURLINFO_SSL_DATA_OUT
				m.lcBytes = "6 CURLINFO_SSL_DATA_OUT" + CRLF
		
			Otherwise
				m.lcBytes = Transform(m.pnInfoType) + " " + m.lcBytes + CRLF
		Endcase
		
		m.lcBytes = Ttoc(Datetime(), 1) + " " + m.lcBytes
		
		This._FileWrite(m.pnLocalFileHandle, m.lcBytes)
		
		Return 0
		
	ENDPROC

	PROCEDURE _destroycallbacks
		*!* _DestroyCallBacks
		
		If This._ReadCallBackPtr # 0
			DestroyCallbackFunc(This._ReadCallBackPtr)
		Endif
		
		If This._WriteCallBackPtr # 0
			DestroyCallbackFunc(This._WriteCallBackPtr)
		Endif
		
		If This._DebugCallBackPtr # 0
			DestroyCallbackFunc(This._DebugCallBackPtr)
		Endif
		
		If This._ProgressCallBackPtr # 0
			DestroyCallbackFunc(This._ProgressCallBackPtr)
		Endif
		
		If This._SeekCallBackPtr # 0
			DestroyCallbackFunc(This._SeekCallBackPtr)
		Endif
		
		If This._HeaderCallBackPtr # 0
			DestroyCallbackFunc(This._HeaderCallBackPtr)
		Endif
		
		Return
		
	ENDPROC

	PROCEDURE _fileclose		&& Flushes and closes a file or communication port opened with a low-level file function.
		*!* _FileClose(nFileHandle)
		
		Lparameters pnFileHandle As Integer
		
		Local ;
			lnApiRetVal As Integer, ;
			llRetVal As Boolean
		
		m.lnApiRetVal = apiCloseHandle(m.pnFileHandle)
		
		If m.lnApiRetVal = 0 Then
			m.llRetVal = FALSE
		Else
			m.llRetVal = TRUE
		Endif
		
		Return m.llRetVal
		
		
	ENDPROC

	PROCEDURE _filecreate		&& Creates and opens a low-level file.
		*!* _FileCreate(cFileName [, nFileAttribute] [, nShareMode)
		
		*!* Since the native Fwrite, Fread, etc. functions eat memory like there
		*!* is no tomorrow, we just reimplement the low level file functions here
		
		Lparameters pcFileName As String, pnAttribute As Integer, pnShareMode As Integer
		
		Local ;
			lnDesiredAccess As Integer, ;
			lnSecurityAttributes As Integer, ;
			lnCreationDisposition As Integer, ;
			lnFlagsAndAttributes As Integer, ;
			lnTemplateFile As Integer, ;
			lnFileHandle As Integer
		
		If Vartype(pcFileName) # "C" Then
			Return -1
		Endif
		
		If Vartype(m.pnAttribute) # "N" Then
			m.pnAttribute = 0
		Endif
		
		If Vartype(m.pnShareMode) # "N" Then
			m.pnShareMode = 0
		Endif
		
		m.lnDesiredAccess = GENERIC_READ + GENERIC_WRITE
		
		Do Case
			Case m.pnAttribute = 0
				m.lnFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL
		
			Case m.pnAttribute = 1
				m.lnFlagsAndAttributes = FILE_ATTRIBUTE_READONLY
		
			Case m.pnAttribute = 2
				m.lnFlagsAndAttributes = FILE_ATTRIBUTE_HIDDEN
		
			Case m.pnAttribute = 3
				m.lnFlagsAndAttributes = FILE_ATTRIBUTE_READONLY + FILE_ATTRIBUTE_HIDDEN
		
			Case m.pnAttribute = 4
				m.lnFlagsAndAttributes = FILE_ATTRIBUTE_SYSTEM
		
			Case m.pnAttribute = 5
				m.lnFlagsAndAttributes = FILE_ATTRIBUTE_READONLY + FILE_ATTRIBUTE_SYSTEM
		
			Case m.pnAttribute = 6
				m.lnFlagsAndAttributes = FILE_ATTRIBUTE_SYSTEM + FILE_ATTRIBUTE_HIDDEN
		
			Case m.pnAttribute = 7
				m.lnFlagsAndAttributes = FILE_ATTRIBUTE_READONLY + FILE_ATTRIBUTE_HIDDEN + FILE_ATTRIBUTE_SYSTEM
		
		Endcase
		
		m.lnSecurityAttributes = 0
		m.lnCreationDisposition = CREATE_ALWAYS
		m.lnTemplateFile = 0
		
		m.lnFileHandle = apiCreateFile( ;
			m.pcFileName, ;
			m.lnDesiredAccess, ;
			m.pnShareMode, ;
			m.lnSecurityAttributes, ;
			m.lnCreationDisposition, ;
			m.lnFlagsAndAttributes, ;
			m.lnTemplateFile)
		
		Return m.lnFileHandle
		
		
	ENDPROC

	PROCEDURE _fileopen		&& Opens a file for use with low-level file functions.
		*!* _FileOpen(cFileName [, nAttribute] [, nShareMode])
		
		Lparameters pcFileName As String, pnAttribute As Integer, pnShareMode as Integer
		
		Local ;
			lnDesiredAccess As Integer, ;
			lnSecurityAttributes As Integer, ;
			lnCreationDisposition As Integer, ;
			lnFlagsAndAttributes As Integer, ;
			lnTemplateFile As Integer, ;
			lnBufferFlag As Integer, ;
			lnFileHandle As Integer
		
		If Vartype(pcFileName) # "C" Then
			Return -1
		Endif
		
		If Vartype(m.pnAttribute) # "N" Then
			m.pnAttribute = 0
		Endif
		
		If Vartype(m.pnShareMode) # "N" Then
			m.pnShareMode = 0
		Endif
		
		Do Case
			Case m.pnAttribute = 0
				m.lnDesiredAccess = GENERIC_READ
				m.lnBufferFlag = 0
		
			Case m.pnAttribute = 1
				m.lnDesiredAccess = GENERIC_WRITE
				m.lnBufferFlag = 0
		
			Case m.pnAttribute = 2
				m.lnDesiredAccess = GENERIC_READ + GENERIC_WRITE
				m.lnBufferFlag = 0
		
			Case m.pnAttribute = 10
				m.lnDesiredAccess = GENERIC_READ
				m.lnBufferFlag = FILE_FLAG_WRITE_THROUGH
		
			Case m.pnAttribute = 11
				m.lnDesiredAccess = GENERIC_WRITE
				m.lnBufferFlag = FILE_FLAG_WRITE_THROUGH
		
			Case m.pnAttribute = 12
				m.lnDesiredAccess = GENERIC_READ + GENERIC_WRITE
				m.lnBufferFlag = FILE_FLAG_WRITE_THROUGH
		
			Otherwise
				m.lnDesiredAccess = GENERIC_READ
				m.lnBufferFlag = 0
		Endcase
		
		m.lnSecurityAttributes = 0
		m.lnCreationDisposition = OPEN_EXISTING
		m.lnFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL + m.lnBufferFlag
		m.lnTemplateFile = 0
		
		m.lnFileHandle = apiCreateFile( ;
			m.pcFilename, ;
			m.lnDesiredAccess, ;
			m.pnShareMode, ;
			m.lnSecurityAttributes, ;
			m.lnCreationDisposition, ;
			m.lnFlagsAndAttributes, ;
			m.lnTemplateFile)
		
		Return m.lnFileHandle
		
		
	ENDPROC

	PROCEDURE _fileread
		*!* FileRead(nFileHandle, nBytes)
		
		Lparameters pnFileHandle As Integer, pnBytes As Integer
		
		Local ;
			lcByteString As String, ;
			lnBytesRead As Integer, ;
			lnApiRetVal As Integer, ;
			lnOverlapped As Integer
		
		m.lnBytesRead = 0
		m.lcByteString = Space(m.pnBytes)
		m.lnOverlapped = 0
		
		m.lnApiRetVal = apiReadFile(m.pnFileHandle, ;
			@m.lcByteString, ;
			m.pnBytes , ;
			@m.lnBytesRead , ;
			m.lnOverlapped)
		
		If m.lnApiRetVal = 0 Then
			m.lcByteString = ""
		Else
			m.lcByteString = Left(m.lcByteString, m.lnBytesRead)
		Endif
		
		Return m.lcByteString
		
	ENDPROC

	PROCEDURE _fileseek		&& Moves the file pointer in a file opened with a low-level file Moves the file pointer in a file opened with a low-level file Moves the file pointer in a file opened with a low-level file function.
		*!* _FileSeek(nFileHandle, nBytesMoved [, nRelativePosition])
		
		Lparameters pnFileHandle As Integer, pnBytesToMove As Integer , pnRelativePosition As Integer
		
		Local ;
			lnDistanceToMoveLo As Integer, ;
			lnDistanceToMoveHi As Integer, ;
			lnNewFilePointerLo As Integer, ;
			lnNewFilePointerHi As Integer, ;
			lcNewFilePointer As String, ;
			lnNewFilePointer As Integer, ;
			lnApiRetVal As Integer
		
		If Vartype(m.pnFileHandle) # "N" Then
			m.pnFileHandle = 0
		Endif
		
		If m.pnFileHandle = 0 Then
			Return 0
		Endif
		
		If Vartype(m.pnBytesToMove) # "N" Then
			m.pnBytesToMove = 0
		Endif
		
		If Vartype(m.pnRelativePosition) # "N" Then
			m.pnRelativePosition = 0
		Endif
		
		*!* Split large integer into low unsigned and high signed
		m.lnDistanceToMoveLo = m.pnBytesToMove % 2^32
		m.lnDistanceToMoveHi = Int((m.pnBytesToMove - m.lnDistanceToMoveLo ) / 2^32)
		
		If m.lnDistanceToMoveLo < 0 Then
			m.lnDistanceToMoveLo = m.lnDistanceToMoveLo + 2^32
		Endif
		
		m.lcNewFilePointer = 0h0000000000000000
		
		m.lnApiRetVal = ;
			apiSetFilePointerEx( ;
			m.pnFileHandle , ;
			m.lnDistanceToMoveLo, ;
			m.lnDistanceToMoveHi, ;
			@m.lcNewFilePointer, ;
			m.pnRelativePosition )
		
		If m.lnApiRetVal = 0 Then
			m.lnNewFilePointer = -1
		Else
		
			m.lnNewFilePointerLo = CToBin(Left(m.lcNewFilePointer, 4), "4rs")
			m.lnNewFilePointerHi = CToBin(Right(m.lcNewFilePointer, 4), "4rs")
		
			If m.lnNewFilePointerLo < 0 Then
				m.lnNewFilePointerLo = m.lnNewFilePointerLo + 2^32
			Endif
			m.lnNewFilePointer = m.lnNewFilePointerLo + m.lnNewFilePointerHi * 2^32
		Endif
		
		Return m.lnNewFilePointer
		
		
	ENDPROC

	PROCEDURE _filesize
		*!* FileSize(cFileName | nFileHandle)
		
		Lparameters puFnameOrFhandle
		
		Local ;
			lnFileSize As Integer, ;
			llCloseFile As Boolean, ;
			lnFileHandle As Integer, ;
			lcLargeInt As String, ;
			lnApiRetVal As Integer
		
		m.lnFileSize = -1
		m.lnFileHandle = -1
		m.llCloseFile = FALSE
		
		Do Case
			Case Vartype(m.puFnameOrFhandle) = "N"
				m.lnFileHandle = m.puFnameOrFhandle
		
			Case Vartype(m.puFnameOrFhandle) = "C"
				m.llCloseFile = TRUE
				m.lnFileHandle = This._FileOpen(m.puFnameOrFhandle, 0)
		
			Otherwise
				Return m.lnFileSize
		Endcase
		
		If m.lnFileHandle # -1
		
			m.lcLargeInt = 0h0000000000000000
			m.lnApiRetVal = apiGetFileSizeEx(m.lnFileHandle, @m.lcLargeInt)
		
			If m.lnApiRetVal # 0 Then
		
				m.lnFileSizeLow = CToBin(Left(m.lcLargeInt, 4), "4rs")
				m.lnFileSizeHigh = CToBin(Right(m.lcLargeInt, 4), "4rs")
		
				If m.lnFileSizeLow < 0 Then
					m.lnFileSizeLow = m.lnFileSizeLow + 2^32
				Endif
		
				m.lnFileSize = m.lnFileSizeLow + m.lnFileSizeHigh * 2^32
		
			Endif
		Endif
		
		*!* Close file
		If m.llCloseFile = TRUE
			This._FileClose(m.lnFileHandle)
		Endif
		
		Return m.lnFileSize
		
	ENDPROC

	PROCEDURE _filewrite
		*!* FileWrite(nFileHandle, cExpression [, nCharactersWritten])
		
		Lparameters m.pnFileHandle As Integer, m.pcExpression As String, m.pnCharactersWritten As Integer
		
		Local ;
			m.lnBytesWritten As Integer, ;
			m.lnOverlapped As Integer, ;
			m.lnApiRetVal As Integer
		
		m.lnBytesWritten = 0
		m.lnOverlapped = 0
		
		If Vartype(m.pnCharactersWritten) <> "N" Then
			m.pnCharactersWritten = Len(m.pcExpression)
		Endif
		
		m.lnApiRetVal = apiWriteFile(m.pnFileHandle, ;
			m.pcExpression, ;
			m.pnCharactersWritten , ;
			@m.lnBytesWritten, ;
			m.lnOverlapped)
		
		Return m.lnBytesWritten
	ENDPROC

	PROCEDURE _ftplistmlsd
		*!* _FtpListMlsd
		
		Lparameters pcUrl As String
		
		Local ;
			lcListDirectoryDetails, ;
			lnx, ;
			lnWordNum, ;
			lcWord
		
		Local Array laListDirectoryDetails(1)
		
		m.lcListDirectoryDetails = This.FtpListDirectoryDetails(m.pcUrl, TRUE)
		
		This.FtpFileCount = Alines(m.laListDirectoryDetails, m.lcListDirectoryDetails)
		
		If This.FtpFileCount = 0 Then
			Return This.FtpFileCount
		Endif
		
		Dimension This.FtpFiles(This.FtpFileCount, 4)
		
		*!*	1 File name Character
		*!*	2 File size Numeric
		*!*	3 DateTime last modified DateTime
		*!*	4 File attributes Character "A" or "D"
		
		For m.lnx = 1 To This.FtpFileCount
		
			This.FtpFiles(m.lnx, 2) = 0
		
			For m.lnWordNum = 1 To Getwordcount(m.laListDirectoryDetails(m.lnx), ";")
		
				m.lcWord = Getwordnum(m.laListDirectoryDetails(m.lnx), m.lnWordNum, ";")
		
				Do Case
		
					Case "type=" $ m.lcWord
						*!* type=file
						If "=dir" $ m.lcWord Then
							This.FtpFiles(m.lnx, 4) = "D"
						Else
							This.FtpFiles(m.lnx, 4) = "A"
						Endif
		
					Case "modify=" $ m.lcWord
						*!* modify=20070703171840
						m.lcWord = Getwordnum(m.lcWord, 2, "=")
						This.FtpFiles(m.lnx, 3) = ;
							Datetime(Val(Substr(m.lcWord, 1, 4)), ;
							Val(Substr(m.lcWord, 5, 2)), ;
							Val(Substr(m.lcWord, 7, 2)), ;
							Val(Substr(m.lcWord, 9, 2)), ;
							Val(Substr(m.lcWord, 11, 2)), ;
							Val(Substr(m.lcWord, 13, 2)))
		
					Case "size=" $ m.lcWord
						*!* size=279658
						m.lcWord = Getwordnum(m.lcWord, 2, "=")
						This.FtpFiles(m.lnx, 2) = Val(m.lcWord)
		
					Case m.lnWordNum = Getwordcount(m.laListDirectoryDetails(m.lnx), ";")
						This.FtpFiles(m.lnx, 1) = m.pcUrl + Right(m.lcWord, Len(m.lcWord) - 1)
		
				Endcase
		
			Endfor
		
		Endfor
		
	ENDPROC

	PROCEDURE _ftplistplain
		*!* _FtpListPlain
		
		Lparameters pcUrl As String
		
		Local ;
			lcListDirectory, ;
			lcListDirectoryDetails, ;
			lnx
		
		Local Array laListDirectoryDetails(1)
		Local Array laListDirectory(1)
		
		m.lcListDirectory = This.FtpListDirectory(m.pcUrl)
		This.FtpFileCount = Alines(m.laListDirectory, m.lcListDirectory)
		
		If This.FtpFileCount = 0 Then
			Return This.FtpFileCount
		Endif
		
		m.lcListDirectoryDetails = This.FtpListDirectoryDetails(m.pcUrl)
		Alines(m.laListDirectoryDetails, m.lcListDirectoryDetails)
		
		Dimension This.FtpFiles(This.FtpFileCount, 4)
		
		*!*	1 File name Character
		*!*	2 File size Numeric
		*!*	3 DateTime last modified DateTime
		*!*	4 File attributes Character "A" or "D"
		
		*!* Set options to get file date and time:
		
		For m.lnx = 1 To This.FtpFileCount
		
			*!* File/Directory name:
			This.FtpFiles(m.lnx, 1) = m.pcUrl + m.laListDirectory(m.lnx)
		
			*!* File/Directory datetime:
			This.FtpFiles(m.lnx, 3) = This.GetDateTimeStamp(This.FtpFiles(m.lnx, 1))
		
			If Upper(Left(m.laListDirectoryDetails(m.lnx), 1)) = "D"  Or "<DIR>" $ m.laListDirectoryDetails(m.lnx) Then
				This.FtpFiles(m.lnx, 2) = 0
				This.FtpFiles(m.lnx, 4) = "D"
			Else
				This.FtpFiles(m.lnx, 2) = This.GetFileSize(This.FtpFiles(m.lnx, 1), TRUE)
				This.FtpFiles(m.lnx, 4) = "A"
			Endif
		
		Endfor
		
	ENDPROC

	PROCEDURE _gettickcount
		*!* _GetTickCount
		
		Local lnTickCount As Integer
		
		m.lnTickCount = apiGetTickCount()
		
		If m.lnTickCount < 0 Then
			m.lnTickCount = m.lnTickCount + 2^32
		Endif
		
		Return m.lnTickCount
		
	ENDPROC

	PROCEDURE _headercallback
		*!* _HeaderCallBack
		
		Lparameters pnBufferAddress, pnSize, pnItems, pnLocalFileHandle
		
		Local lcBytes As String
		
		m.lcBytes = Strtran(Sys(2600, m.pnBufferAddress, m.pnSize * m.pnItems), CRLF, "")
		
		*!* This is used by FtpGetFeatures, the only way to collect the response is here:
		If This._FtpGetFeaturesStatus # 0 Then
			Do Case
				Case This._FtpGetFeaturesStatus = 1 And Left(m.lcBytes, 3) = "211"
					This._FtpGetFeaturesStatus = 2
		
				Case This._FtpGetFeaturesStatus = 2 And Left(m.lcBytes, 3) = "211"
					This._FtpGetFeaturesStatus = 0
					This._FtpGetFeaturesData = Left(This._FtpGetFeaturesData, Len(This._FtpGetFeaturesData) - 1)
		
				Case This._FtpGetFeaturesStatus = 2
					This._FtpGetFeaturesData = This._FtpGetFeaturesData + Alltrim(m.lcBytes) + "|"
			Endcase
		Endif
		
		Return m.pnSize * m.pnItems
		
	ENDPROC

	PROCEDURE _progresscallback		&& This function gets called by libcurl with a frequent interval during operation.
		*!* _ProgressCallBack
		
		Lparameters pnClientp, pnDlTotal, pnDlNow, pnUlTotal, pnUlNow
		
		*!* Returning a non-zero value from this callback will cause libcurl
		*!* to abort the transfer and return CURLE_ABORTED_BY_CALLBACK.
		
		Local ;
			lnBytesTotal As Integer, ;
			lnBytesDone As Integer, ;
			lnBytesLeft As Integer, ;
			lnSpeed As Integer, ;
			lnTimeTotal As Integer, ;
			lnTimeDone As Integer, ;
			lnTimeLeft As Integer, ;
			lnTickCount As Integer
		
		m.lnTickCount = This._GetTickCount()
		
		*!* Only continue if at least 1 second has passed from the last time TransferProgress
		*!* was called.
		
		m.lnBytesTotal = Int(Max(m.pnDlTotal, m.pnUlTotal))
		m.lnBytesDone = Int(Max(m.pnDlNow, m.pnUlNow))
		m.lnBytesLeft = m.lnBytesTotal - m.lnBytesDone
		
		If m.lnBytesDone # 0 And m.lnBytesLeft # 0 And Abs(m.lnTickCount - This._ProgressCallBackTickCount) < 1000 Then
			Return 0
		Endif
		
		m.lnTimeDone = Int(Round((m.lnTickCount - This._PerformStartTime) / 1000, 0))
		
		This._ProgressCallBackTickCount = m.lnTickCount
		
		If m.lnTimeDone > 0 And m.lnBytesDone > 0 Then
			m.lnSpeed = Int(Round(m.lnBytesDone / m.lnTimeDone, 0))
			m.lnTimeLeft = Int(Round(m.lnBytesLeft / m.lnSpeed, 0))
			m.lnTimeTotal = Int(Round(m.lnBytesTotal / m.lnSpeed, 0))
		Else
			m.lnSpeed = 0
			m.lnTimeLeft = 0
			m.lnTimeTotal = 0
		Endif
		
		Raiseevent(This, "TransferProgress", m.lnBytesTotal, m.lnBytesDone, m.lnBytesLeft, m.lnSpeed, m.lnTimeTotal, m.lnTimeDone, m.lnTimeLeft)
		
		Release m.lnBytesTotal, m.lnBytesDone, m.lnBytesLeft, m.lnSpeed, m.lnTimeTotal, m.lnTimeDone, m.lnTimeLeft
		
		Return 0
		
	ENDPROC

	PROCEDURE _readcallback		&& This function gets called by libcurl as soon as it needs to read data in order to send it to the peer.
		*!* _ReadCallBack
		
		*!* This method is called by vfp2c32 at the request of libcurl when
		*!* libcurl needs more data to send
		
		Lparameters pnBufferAddress, pnSize, pnItems, pnLocalFileHandle
		
		*!* Allow VFP to process Windows events
		DoEvents
		
		Local ;
			lnBytesToRead As Integer, ;
			lnBytesRead As Integer, ;
			lnResult As Integer
		
		m.lnBytesToRead = m.pnSize * m.pnItems
		m.lnBytesRead = 0
		
		*!* Here we use the api function ReadFile to read the file directly to the libcurl buffer
		*!* Since we already have a pointer to the data, we pass that pointer to ReadFile 
		
		If apiCurlReadFile(m.pnLocalFileHandle, m.pnBufferAddress, m.lnBytesToRead, @m.lnBytesRead, 0) # 0 Then
		
			*!* Here we "process" m.lnBytesRead so libcurl will accept it
			*!* if we just pass m.lnBytesRead, it looks like m.lnBytesRead # what libcurl expects, but in
			*!* VFP it looks like the same value
			m.lnResult = CToBin(BinToC(m.lnBytesRead))
		Else
			m.lnResult = 0
		Endif
		
		Release m.lnBytesToRead, m.lnBytesRead
		
		*!*	The read callback may return CURL_READFUNC_ABORT to stop the current operation
		*!*	immediately, resulting in a CURLE_ABORTED_BY_CALLBACK error code from the transfer
		
		*!*	From 7.18.0, the function can return CURL_READFUNC_PAUSE which then will cause reading
		*!*	from this connection to become paused. See curl_easy_pause(3) for further details.
		
		If This._CancelTransfer = TRUE Then
			m.lnResult = CURL_READFUNC_ABORT
		Endif
		
		Return m.lnResult
		
	ENDPROC

	PROCEDURE _restoresettings
		*!* _RestoreSettings()
		
		This.CurlOptDirListOnly = This._Settings(1)
		This.CurlOptFileTime = This._Settings(2)
		
		If Not Empty(This._Settings(3))
			This.CurlOptCustomRequest = This._Settings(3)
		Endif
		
		This.CurlOptNoBody = This._Settings(4)
		
		If Not Empty(This._Settings(5))
			This.CurlOptPostQuote = This._Settings(5)
		Endif
		
		If Not Empty(This._Settings(6))
			This.CurlOptPreQuote = This._Settings(6)
		Endif
		
		If Not Empty(This._Settings(7))
			This.CurlOptQuote = This._Settings(7)
		Endif
		
		This.CurlOptUpload = This._Settings(8)
		
		If Not Empty(This._Settings(9))
			This.CurlOptUrl = This._Settings(9)
		Endif
		
		This.CurlOptAppend = This._Settings(10)
		This.CurlOptFtpCreateMissingDirs = This._Settings(11)
		This.CUrlOptResumeFrom = This._Settings(12)
		This.CurlOptPost = This._Settings(13)
		This.CurlOptHttpGet = This._Settings(14)
		
	ENDPROC

	PROCEDURE _savesettings
		*!* _SaveSettings
		
		Dimension This._Settings(14)
		
		This._Settings(1) = This.CurlOptDirListOnly
		This._Settings(2) = This.CurlOptFileTime
		This._Settings(3) = This.CurlOptCustomRequest
		This._Settings(4) = This.CurlOptNoBody
		This._Settings(5) = This.CurlOptPostQuote
		This._Settings(6) = This.CurlOptPreQuote
		This._Settings(7) = This.CurlOptQuote
		This._Settings(8) = This.CurlOptUpload
		This._Settings(9) = This.CurlOptUrl
		This._Settings(10) = This.CurlOptAppend
		This._Settings(11) = This.CurlOptFtpCreateMissingDirs
		This._Settings(12) = This.CurlOptResumeFrom
		This._Settings(13) = This.CurlOptPost
		This._Settings(14) = This.CurlOptHttpGet
		
		This.CurlOptCustomRequest = ""
		This.CurlOptPostQuote = ""
		This.CurlOptPreQuote = ""
		This.CurlOptQuote = ""
		
		
		
		
		
		
	ENDPROC

	PROCEDURE _seekcallback		&& This function gets called by libcurl to seek to a certain position in the input stream and can be used to fast forward a file in a resumed upload.
		*!* _SeekCallBack
		
		*!* This method is called by vfp2c32 at the request of libcurl when
		*!* libcurl wants to move the file pointer
		
		Lparameters pnLocalFileHandle, pnOffset, pnOrigin
		
		Local lnSeek
		
		If m.pnLocalFileHandle > 0 Then
			m.lnSeek = This._FileSeek(m.pnLocalFileHandle, m.pnOffset, m.pnOrigin)
		Endif
		
		Return 0
		
	ENDPROC

	PROCEDURE _setdefaultproperties
		*!* _SetDefaultProperties()
		
		Local lcCertFile as String
		*!* Setup certificates file name and location
		*!* Certificates here: http://curl.haxx.se/ca/cacert.pem
		*!* save file as libcurl.crt
		
		m.lcCertFile = Addbs(Justpath(This.ClassLibrary)) + "libcurl.crt"
		apiCurlEasySetOptString(This.CurlEasyHandle, CURLOPT_CAINFO, m.lcCertFile)
		
		*!* Setup read function callback (In cUrl, WRITE is download, READ is upload)
		apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_READFUNCTION, This._ReadCallBackPtr)
		apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_READDATA, 0)
		
		*!* Setup seek function callback
		apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_SEEKFUNCTION, This._SeekCallBackPtr)
		apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_SEEKDATA, 0)
		
		*!* Setup write function callback (In cUrl, WRITE is download, READ is upload)
		apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_WRITEFUNCTION, This._WriteCallBackPtr)
		apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_WRITEDATA, 0)
		
		*!* Setup Debug function callback
		apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_DEBUGFUNCTION, This._DebugCallBackPtr)
		apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_DEBUGDATA, 0)
		
		This._DataBuffer = ""
		
		
		
	ENDPROC

	PROCEDURE _setuplogfile
		*!* _SetupLogFile()
		
		If This.CurlOptVerbose = TRUE Then
		
			*!* if the log file is closed, open it:
			If This._DebugFileHandle = 0 Then
				This._DebugFileHandle = This._FileOpen(This.LogFileName, 2, FILE_SHARE_WRITE + FILE_SHARE_READ)
				If This._DebugFileHandle = -1 Then
					This._DebugFileHandle = This._FileCreate(Addbs(Justpath(This.ClassLibrary)) + "libcurl.log", 0, FILE_SHARE_WRITE + FILE_SHARE_READ)
				Endif
				This._FileSeek(This._DebugFileHandle, 0, 2)
			Endif
			
			*!* set the log file handle
			apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_DEBUGDATA, This._DebugFileHandle)
		
		Else
		
			*!* If the log file is open, close it
			If This._DebugFileHandle # 0 Then
				This._FileClose(This._DebugFileHandle)
				This._DebugFileHandle = 0
			ENDIF
			
			*!* set the log file handle to 0
			apiCurlEasySetOptInteger(This.CurlEasyHandle, CURLOPT_DEBUGDATA, 0)
		Endif
		
	ENDPROC

	PROCEDURE _writecallback		&& This function gets called by libcurl as soon as there is data received that needs to be saved.
		*!* CurlWriteCallBack
		
		*!* This method is called by vfp2c32 at the request of libcurl when
		*!* libcurl wants to give us received data
		
		Lparameters pnBufferAddress, pnSize, pnItems, pnLocalFileHandle
		
		*!* Allow VFP to process Windows events
		DoEvents
		
		Local ;
			lnBytesToWrite As Integer, ;
			lnBytesWritten As Integer, ;
			lnResult As Integer
		
		m.lnBytesToWrite = m.pnSize * m.pnItems
		m.lnBytesWritten = 0
		
		If m.pnLocalFileHandle > 0 Then
		
		*!* Here we use the api function WriteFile to Write to the file directly from the libcurl buffer
		*!* Since we already have a pointer to the data, we pass that pointer to WriteFile 
		
			If apiCurlWriteFile(m.pnLocalFileHandle, m.pnBufferAddress, m.lnBytesToWrite, @m.lnBytesWritten, 0) # 0 Then
				
				*!* now we "process" m.lnBytesWritten so libcurl will accept it
				*!* if we just pass m.lnBytesWritten , it looks like m.lnBytesWritten # what libcurl expects, but in
				*!* VFP it looks like the same value
				m.lnResult = CToBin(BinToC(m.lnBytesWritten))
			Else
				m.lnResult = 0
			Endif
		
		Else
			*!* Add data to internal buffer
			This._DataBuffer = This._DataBuffer + Sys(2600, m.pnBufferAddress, m.lnBytesToWrite)
			m.lnResult = m.lnBytesToWrite
		Endif
		
		Release m.lnBytesToWrite, m.lnBytesWritten
		
		*!*	/* This is a magic return code for the write callback that, when returned,
		*!*	   will signal libcurl to pause receiving on the current transfer. */
		*!*	#define CURL_WRITEFUNC_PAUSE 0x10000001
		
		*!* Since there is no CURL_WRITEFUNC_ABORT equivalent to CURL_READFUNC_ABORT
		*!* we just return 0 here and fake the curl_easy_perform return code
		
		If This._CancelTransfer = TRUE Then
			This._PerformRetCode = CURLE_ABORTED_BY_CALLBACK
			m.lnResult = 0
		Endif
		
		Return m.lnResult
		
	ENDPROC

	PROCEDURE lblname.Init
		Return FALSE
		
	ENDPROC

ENDDEFINE
